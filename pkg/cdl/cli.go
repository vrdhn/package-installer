// Code generated by cligen; DO NOT EDIT.

package cdl

import (
	"fmt"
)

type FlagDef struct {
	Name  string
	Short string
	Type  string
	Desc  string
}

type ArgDef struct {
	Name string
	Type string
	Desc string
}

type CommandDef struct {
	Name        string
	FullCommand string
	Desc        string
	Safe        bool
	Args        []ArgDef
	Flags       []FlagDef
	Subs        []CommandDef
	Examples    []string
}

type TopicDef struct {
	Name string
	Desc string
	Text string
}

type GlobalFlags struct {
	Help    bool
	Verbose bool
	Config  string
}

type CaveAddpkgParams struct {
	GlobalFlags
	Package string
}

type CaveEnterParams struct {
	GlobalFlags
	_ struct{}
}

type CaveInfoParams struct {
	GlobalFlags
	_ struct{}
}

type CaveInitParams struct {
	GlobalFlags
	_ struct{}
}

type CaveListParams struct {
	GlobalFlags
	_ struct{}
}

type CaveRunParams struct {
	GlobalFlags
	Command string
	Variant string
}

type CaveSyncParams struct {
	GlobalFlags
	_ struct{}
}

type CaveUseParams struct {
	GlobalFlags
	Cave string
}

type DiskCleanParams struct {
	GlobalFlags
	_ struct{}
}

type DiskInfoParams struct {
	GlobalFlags
	_ struct{}
}

type DiskUninstallParams struct {
	GlobalFlags
	Force bool
}

type PkgInstallParams struct {
	GlobalFlags
	Package string
	Force   bool
}

type PkgListParams struct {
	GlobalFlags
	Package string
	All     bool
	Index   bool
}

type RecipeReplParams struct {
	GlobalFlags
	File string
}

type RepoAddParams struct {
	GlobalFlags
	Path string
}

type RepoListParams struct {
	GlobalFlags
	_ struct{}
}

type RepoSyncParams struct {
	GlobalFlags
	_ struct{}
}

type SelfUpdateParams struct {
	GlobalFlags
	_ struct{}
}

type VersionParams struct {
	GlobalFlags
	_ struct{}
}

type Handlers[T any] interface {
	Help(args []string) (T, error)
	RunCaveAddpkg(params *CaveAddpkgParams) (T, error)
	RunCaveEnter(params *CaveEnterParams) (T, error)
	RunCaveInfo(params *CaveInfoParams) (T, error)
	RunCaveInit(params *CaveInitParams) (T, error)
	RunCaveList(params *CaveListParams) (T, error)
	RunCaveRun(params *CaveRunParams) (T, error)
	RunCaveSync(params *CaveSyncParams) (T, error)
	RunCaveUse(params *CaveUseParams) (T, error)
	RunDiskClean(params *DiskCleanParams) (T, error)
	RunDiskInfo(params *DiskInfoParams) (T, error)
	RunDiskUninstall(params *DiskUninstallParams) (T, error)
	RunPkgInstall(params *PkgInstallParams) (T, error)
	RunPkgList(params *PkgListParams) (T, error)
	RunRecipeRepl(params *RecipeReplParams) (T, error)
	RunRepoAdd(params *RepoAddParams) (T, error)
	RunRepoList(params *RepoListParams) (T, error)
	RunRepoSync(params *RepoSyncParams) (T, error)
	RunSelfUpdate(params *SelfUpdateParams) (T, error)
	RunVersion(params *VersionParams) (T, error)
}

type Action[T any] func(h Handlers[T]) (T, error)

var CliGlobalFlags = []FlagDef{
	{Name: "help", Short: "h", Type: "bool", Desc: "Show help information"},
	{Name: "verbose", Short: "v", Type: "bool", Desc: "Enable verbose output"},
	{Name: "config", Short: "c", Type: "string", Desc: "Path to config file"},
}

var CliTopics = []TopicDef{
	{Name: "about", Desc: "Overview", Text: " pi is a universal, workspace-based package installer that manages dependencies\n across various languages and runtimes (Node.js, Go, Java, etc.) using isolated sandboxes.\n It ensures deterministic environments without polluting your host system."},
	{Name: "architecture", Desc: "Architecture & Patterns", Text: " pi is built for safety and speed using the following patterns:\n - Immutability: Core structures use ReadOnly/Writable interfaces to prevent accidental mutation.\n - Pipeline: Installation follows a strict Resolve -> Download -> Install -> Reify flow.\n - Concurrency: Go's goroutines are used for parallel downloads and extractions."},
	{Name: "caves", Desc: "The Cave Sandbox", Text: " A 'Cave' is an isolated environment powered by Linux bubblewrap.\n - Isolation: Restricts filesystem access to the workspace and a private HOME.\n - Zero Pollution: Tools installed for one project do not affect the host or other projects.\n - Redirected Home: Environment variables (GOPATH, CARGO_HOME) are redirected into the Cave."},
	{Name: "workspace", Desc: "Workspace & Manifests", Text: " Workspaces are managed via the 'pi.cave.json' manifest.\n - Symlink Forest: pi populates .local/bin in the Cave Home with symlinks to the package cache.\n - Variants: Support for different environment configurations (e.g., 'legacy' or 'testing')\n within the same workspace."},
	{Name: "versions", Desc: "Version Formats & Queries", Text: " pi supports flexible versioning schemes and semantic keywords for package resolution.\n\n Keywords:\n - latest:  (Default) Resolves to the most recent version available.\n - stable:  Resolves to the latest release marked as stable by the upstream provider.\n - lts:     (Node.js/Java) Resolves to the latest Long Term Support release.\n\n Formats:\n - exact:   pi pkg install nodejs@20.11.0\n - prefix:  pi pkg install nodejs@20 (matches 20.*)\n - names:   pi pkg install npm:typescript@latest (optional prefix)"},
	{Name: "recipes", Desc: "Starlark Recipes", Text: " Recipes describe how packages are discovered and installed.\n - Language: Written in Starlark (a Python dialect).\n - Pure: Recipes are declarative and perform no direct I/O.\n - Discovery: Recipes return a 'DiscoveryRequest' for the host to fetch, then parse the response."},
}

var CliCommands = []CommandDef{

	CommandDef{
		Name:        "help",
		FullCommand: "help",
		Desc:        "Show help information",
		Safe:        true,
	},

	CommandDef{
		Name:        "version",
		FullCommand: "version",
		Desc:        "Show version information",
		Safe:        true,
	},

	CommandDef{
		Name:        "pkg",
		FullCommand: "pkg",
		Desc:        "Manage packages",
		Safe:        false,
		Subs: []CommandDef{

			CommandDef{
				Name:        "install",
				FullCommand: "pkg/install",
				Desc:        "Install a package",
				Safe:        false,
				Args: []ArgDef{
					{Name: "package", Type: "string", Desc: "Package name and version (e.g., nodejs@20)"},
				},
				Flags: []FlagDef{
					{Name: "force", Short: "f", Type: "bool", Desc: "Force reinstallation"},
				},
				Examples: []string{
					"pi pkg install nodejs@20",
					"pi pkg i nodejs@latest",
				},
			},

			CommandDef{
				Name:        "list",
				FullCommand: "pkg/list",
				Desc:        "List available versions for a package",
				Safe:        false,
				Args: []ArgDef{
					{Name: "package", Type: "string", Desc: "Package name (e.g. go)"},
				},
				Flags: []FlagDef{
					{Name: "all", Short: "a", Type: "bool", Desc: "Show all architectures/OSs"},
					{Name: "index", Short: "i", Type: "bool", Desc: "List registry patterns only"},
				},
				Examples: []string{
					"pi pkg list go",
				},
			},
		},
	},

	CommandDef{
		Name:        "recipe",
		FullCommand: "recipe",
		Desc:        "Recipe development",
		Safe:        false,
		Subs: []CommandDef{

			CommandDef{
				Name:        "repl",
				FullCommand: "recipe/repl",
				Desc:        "Run the recipe development REPL",
				Safe:        false,
				Args: []ArgDef{
					{Name: "file", Type: "string", Desc: "Path to recipe file"},
				},
				Examples: []string{
					"pi recipe repl ./recipes/nodejs.star",
				},
			},
		},
	},

	CommandDef{
		Name:        "cave",
		FullCommand: "cave",
		Desc:        "Manage the cave (sandbox)",
		Safe:        false,
		Subs: []CommandDef{

			CommandDef{
				Name:        "info",
				FullCommand: "cave/info",
				Desc:        "Display information about the current cave",
				Safe:        true,
				Examples: []string{
					"pi cave info",
				},
			},

			CommandDef{
				Name:        "list",
				FullCommand: "cave/list",
				Desc:        "List all registered caves and their variants",
				Safe:        false,
				Examples: []string{
					"pi cave list",
				},
			},

			CommandDef{
				Name:        "use",
				FullCommand: "cave/use",
				Desc:        "Start a cave by name from any directory",
				Safe:        false,
				Args: []ArgDef{
					{Name: "cave", Type: "string", Desc: "Cave name and optional variant (e.g., project:dev)"},
				},
				Examples: []string{
					"pi cave use myproject",
					"pi cave use myproject:dev",
				},
			},

			CommandDef{
				Name:        "run",
				FullCommand: "cave/run",
				Desc:        "Run a command inside the cave",
				Safe:        false,
				Args: []ArgDef{
					{Name: "command", Type: "string", Desc: "Command to run"},
				},
				Flags: []FlagDef{
					{Name: "variant", Short: "v", Type: "string", Desc: "Variant to use"},
				},
				Examples: []string{
					"pi cave run ls",
					"pi cave run -v test go test ./...",
				},
			},

			CommandDef{
				Name:        "sync",
				FullCommand: "cave/sync",
				Desc:        "Sync all packages in pi.cave.json",
				Safe:        false,
				Examples: []string{
					"pi cave sync",
				},
			},

			CommandDef{
				Name:        "init",
				FullCommand: "cave/init",
				Desc:        "Initialize a new workspace",
				Safe:        false,
				Examples: []string{
					"pi cave init",
				},
			},

			CommandDef{
				Name:        "addpkg",
				FullCommand: "cave/addpkg",
				Desc:        "Add a package to the cave configuration",
				Safe:        false,
				Args: []ArgDef{
					{Name: "package", Type: "string", Desc: "Package name and version (e.g., go=stable)"},
				},
				Examples: []string{
					"pi cave addpkg go=stable",
				},
			},

			CommandDef{
				Name:        "enter",
				FullCommand: "cave/enter",
				Desc:        "Enter the sandbox shell",
				Safe:        false,
				Examples: []string{
					"pi cave enter",
					"pi enter",
				},
			},
		},
	},

	CommandDef{
		Name:        "disk",
		FullCommand: "disk",
		Desc:        "Manage local storage",
		Safe:        false,
		Subs: []CommandDef{

			CommandDef{
				Name:        "info",
				FullCommand: "disk/info",
				Desc:        "Show disk usage summary",
				Safe:        false,
				Examples: []string{
					"pi disk info",
				},
			},

			CommandDef{
				Name:        "clean",
				FullCommand: "disk/clean",
				Desc:        "Remove all cached data (packages, downloads, discovery cache)",
				Safe:        false,
				Examples: []string{
					"pi disk clean",
				},
			},

			CommandDef{
				Name:        "uninstall",
				FullCommand: "disk/uninstall",
				Desc:        "Wipe all pi data (cache, state, and config)",
				Safe:        false,
				Flags: []FlagDef{
					{Name: "force", Short: "f", Type: "bool", Desc: "Skip confirmation prompt"},
				},
				Examples: []string{
					"pi disk uninstall",
				},
			},
		},
	},

	CommandDef{
		Name:        "self-update",
		FullCommand: "self-update",
		Desc:        "Update pi to the latest version",
		Safe:        false,
		Examples: []string{
			"pi self-update",
		},
	},

	CommandDef{
		Name:        "repo",
		FullCommand: "repo",
		Desc:        "Manage repositories",
		Safe:        false,
		Subs: []CommandDef{

			CommandDef{
				Name:        "list",
				FullCommand: "repo/list",
				Desc:        "List all repositories",
				Safe:        false,
				Examples: []string{
					"pi repo list",
					"pi list",
				},
			},

			CommandDef{
				Name:        "add",
				FullCommand: "repo/add",
				Desc:        "Add a new repository",
				Safe:        false,
				Args: []ArgDef{
					{Name: "path", Type: "string", Desc: "Path to the repository"},
				},
				Examples: []string{
					"pi repo add /path/to/recipes",
				},
			},

			CommandDef{
				Name:        "sync",
				FullCommand: "repo/sync",
				Desc:        "Regenerate the package index from all repositories",
				Safe:        false,
				Examples: []string{
					"pi repo sync",
				},
			},
		},
	},
}

var CliAppName = "pi"
var CliTagline = "Universal package installer for isolated workspaces"

type Invocation struct {
	Command *CommandDef
	Args    map[string]string
	Flags   map[string]any
}

func Parse[T any](args []string) (Action[T], *CommandDef, error) {

	var gf GlobalFlags
	remaining := ProcessGlobalFlags(args, &gf)

	if len(remaining) > 0 && remaining[0] == "help" {
		gf.Help = true
		remaining = remaining[1:]
	}

	if gf.Help || len(remaining) == 0 {
		var helpCmd *CommandDef
		for i := range CliCommands {
			if CliCommands[i].Name == "help" {
				helpCmd = &CliCommands[i]
				break
			}
		}
		return func(h Handlers[T]) (T, error) {
			return h.Help(remaining)
		}, helpCmd, nil
	}

	resolvedCmd, remArgs, err := Resolve(CliCommands, remaining)
	if err != nil {
		return nil, nil, err
	}

	inv := &Invocation{Command: resolvedCmd, Args: make(map[string]string), Flags: make(map[string]any)}
	if err := ParseParams(inv, resolvedCmd, remArgs); err != nil {
		return nil, resolvedCmd, err
	}

	switch resolvedCmd.FullCommand {
	case "cave/addpkg":
		return handleCaveAddpkg[T](inv, gf), resolvedCmd, nil
	case "cave/enter":
		return handleCaveEnter[T](inv, gf), resolvedCmd, nil
	case "cave/info":
		return handleCaveInfo[T](inv, gf), resolvedCmd, nil
	case "cave/init":
		return handleCaveInit[T](inv, gf), resolvedCmd, nil
	case "cave/list":
		return handleCaveList[T](inv, gf), resolvedCmd, nil
	case "cave/run":
		return handleCaveRun[T](inv, gf), resolvedCmd, nil
	case "cave/sync":
		return handleCaveSync[T](inv, gf), resolvedCmd, nil
	case "cave/use":
		return handleCaveUse[T](inv, gf), resolvedCmd, nil
	case "disk/clean":
		return handleDiskClean[T](inv, gf), resolvedCmd, nil
	case "disk/info":
		return handleDiskInfo[T](inv, gf), resolvedCmd, nil
	case "disk/uninstall":
		return handleDiskUninstall[T](inv, gf), resolvedCmd, nil
	case "pkg/install":
		return handlePkgInstall[T](inv, gf), resolvedCmd, nil
	case "pkg/list":
		return handlePkgList[T](inv, gf), resolvedCmd, nil
	case "recipe/repl":
		return handleRecipeRepl[T](inv, gf), resolvedCmd, nil
	case "repo/add":
		return handleRepoAdd[T](inv, gf), resolvedCmd, nil
	case "repo/list":
		return handleRepoList[T](inv, gf), resolvedCmd, nil
	case "repo/sync":
		return handleRepoSync[T](inv, gf), resolvedCmd, nil
	case "self-update":
		return handleSelfUpdate[T](inv, gf), resolvedCmd, nil
	case "version":
		return handleVersion[T](inv, gf), resolvedCmd, nil
	default:
		if len(resolvedCmd.Subs) > 0 {
			return func(h Handlers[T]) (T, error) {
				return h.Help(remaining)
			}, resolvedCmd, nil
		}
		return nil, resolvedCmd, fmt.Errorf("no handler for command: %s", resolvedCmd.FullCommand)
	}
}

func ApplyGlobalFlag(g *GlobalFlags, name string, val any) {
	switch name {
	case "help":
		if b, ok := val.(bool); ok {
			g.Help = b
		}
	case "verbose":
		if b, ok := val.(bool); ok {
			g.Verbose = b
		}
	case "config":
		if s, ok := val.(string); ok {
			g.Config = s
		}
	}
}
func handleCaveAddpkg[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &CaveAddpkgParams{}
	params.GlobalFlags = gf
	params.Package = inv.Args["package"]
	return func(h Handlers[T]) (T, error) {
		return h.RunCaveAddpkg(params)
	}
}
func handleCaveEnter[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &CaveEnterParams{}
	params.GlobalFlags = gf
	return func(h Handlers[T]) (T, error) {
		return h.RunCaveEnter(params)
	}
}
func handleCaveInfo[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &CaveInfoParams{}
	params.GlobalFlags = gf
	return func(h Handlers[T]) (T, error) {
		return h.RunCaveInfo(params)
	}
}
func handleCaveInit[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &CaveInitParams{}
	params.GlobalFlags = gf
	return func(h Handlers[T]) (T, error) {
		return h.RunCaveInit(params)
	}
}
func handleCaveList[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &CaveListParams{}
	params.GlobalFlags = gf
	return func(h Handlers[T]) (T, error) {
		return h.RunCaveList(params)
	}
}
func handleCaveRun[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &CaveRunParams{}
	params.GlobalFlags = gf
	params.Command = inv.Args["command"]
	params.Variant = StringFlag(inv.Flags, "variant")
	return func(h Handlers[T]) (T, error) {
		return h.RunCaveRun(params)
	}
}
func handleCaveSync[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &CaveSyncParams{}
	params.GlobalFlags = gf
	return func(h Handlers[T]) (T, error) {
		return h.RunCaveSync(params)
	}
}
func handleCaveUse[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &CaveUseParams{}
	params.GlobalFlags = gf
	params.Cave = inv.Args["cave"]
	return func(h Handlers[T]) (T, error) {
		return h.RunCaveUse(params)
	}
}
func handleDiskClean[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &DiskCleanParams{}
	params.GlobalFlags = gf
	return func(h Handlers[T]) (T, error) {
		return h.RunDiskClean(params)
	}
}
func handleDiskInfo[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &DiskInfoParams{}
	params.GlobalFlags = gf
	return func(h Handlers[T]) (T, error) {
		return h.RunDiskInfo(params)
	}
}
func handleDiskUninstall[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &DiskUninstallParams{}
	params.GlobalFlags = gf
	params.Force = BoolFlag(inv.Flags, "force")
	return func(h Handlers[T]) (T, error) {
		return h.RunDiskUninstall(params)
	}
}
func handlePkgInstall[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &PkgInstallParams{}
	params.GlobalFlags = gf
	params.Package = inv.Args["package"]
	params.Force = BoolFlag(inv.Flags, "force")
	return func(h Handlers[T]) (T, error) {
		return h.RunPkgInstall(params)
	}
}
func handlePkgList[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &PkgListParams{}
	params.GlobalFlags = gf
	params.Package = inv.Args["package"]
	params.All = BoolFlag(inv.Flags, "all")
	params.Index = BoolFlag(inv.Flags, "index")
	return func(h Handlers[T]) (T, error) {
		return h.RunPkgList(params)
	}
}
func handleRecipeRepl[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &RecipeReplParams{}
	params.GlobalFlags = gf
	params.File = inv.Args["file"]
	return func(h Handlers[T]) (T, error) {
		return h.RunRecipeRepl(params)
	}
}
func handleRepoAdd[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &RepoAddParams{}
	params.GlobalFlags = gf
	params.Path = inv.Args["path"]
	return func(h Handlers[T]) (T, error) {
		return h.RunRepoAdd(params)
	}
}
func handleRepoList[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &RepoListParams{}
	params.GlobalFlags = gf
	return func(h Handlers[T]) (T, error) {
		return h.RunRepoList(params)
	}
}
func handleRepoSync[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &RepoSyncParams{}
	params.GlobalFlags = gf
	return func(h Handlers[T]) (T, error) {
		return h.RunRepoSync(params)
	}
}
func handleSelfUpdate[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &SelfUpdateParams{}
	params.GlobalFlags = gf
	return func(h Handlers[T]) (T, error) {
		return h.RunSelfUpdate(params)
	}
}
func handleVersion[T any](inv *Invocation, gf GlobalFlags) Action[T] {
	params := &VersionParams{}
	params.GlobalFlags = gf
	return func(h Handlers[T]) (T, error) {
		return h.RunVersion(params)
	}
}
