// Code generated by cligen; DO NOT EDIT.

package cli

import (
	"context"
	"fmt"
	"os"
	"strings"
)

type flagDef struct {
	Name  string
	Short string
	Type  string
	Desc  string
}

type argDef struct {
	Name string
	Type string
	Desc string
}

type commandDef struct {
	Name       string
	Desc       string
	SafeInCave bool
	Args       []*argDef
	Flags      []*flagDef
	Subs       []*commandDef
	Parent     *commandDef
	Examples   []string
}

type topicDef struct {
	Name string
	Desc string
	Text string
}

type globalFlags struct {
	Verbose bool
	Config  string
}

type caveAddpkgArgs struct {
	Package string
}

type caveAddpkgFlags struct {
	globalFlags
	_ struct{}
}

type caveEnterArgs struct {
	_ struct{}
}

type caveEnterFlags struct {
	globalFlags
	_ struct{}
}

type caveInfoArgs struct {
	_ struct{}
}

type caveInfoFlags struct {
	globalFlags
	_ struct{}
}

type caveInitArgs struct {
	_ struct{}
}

type caveInitFlags struct {
	globalFlags
	_ struct{}
}

type caveListArgs struct {
	_ struct{}
}

type caveListFlags struct {
	globalFlags
	_ struct{}
}

type caveRunArgs struct {
	Command string
}

type caveRunFlags struct {
	globalFlags
	Variant string
}

type caveSyncArgs struct {
	_ struct{}
}

type caveSyncFlags struct {
	globalFlags
	_ struct{}
}

type caveUseArgs struct {
	Cave string
}

type caveUseFlags struct {
	globalFlags
	_ struct{}
}

type diskCleanArgs struct {
	_ struct{}
}

type diskCleanFlags struct {
	globalFlags
	_ struct{}
}

type diskInfoArgs struct {
	_ struct{}
}

type diskInfoFlags struct {
	globalFlags
	_ struct{}
}

type diskUninstallArgs struct {
	_ struct{}
}

type diskUninstallFlags struct {
	globalFlags
	Force bool
}

type pkgInstallArgs struct {
	Package string
}

type pkgInstallFlags struct {
	globalFlags
	Force bool
}

type pkgListArgs struct {
	Package string
}

type pkgListFlags struct {
	globalFlags
	All   bool
	Index bool
}

type recipeReplArgs struct {
	File string
}

type recipeReplFlags struct {
	globalFlags
	_ struct{}
}

type repoAddArgs struct {
	Name string
	Url  string
}

type repoAddFlags struct {
	globalFlags
	_ struct{}
}

type repoListArgs struct {
	_ struct{}
}

type repoListFlags struct {
	globalFlags
	_ struct{}
}

type versionArgs struct {
	_ struct{}
}

type versionFlags struct {
	globalFlags
	_ struct{}
}

type Handlers interface {
	CaveAddpkg(ctx context.Context, m *Managers, args *caveAddpkgArgs, flags *caveAddpkgFlags) (*ExecutionResult, error)
	CaveEnter(ctx context.Context, m *Managers, args *caveEnterArgs, flags *caveEnterFlags) (*ExecutionResult, error)
	CaveInfo(ctx context.Context, m *Managers, args *caveInfoArgs, flags *caveInfoFlags) (*ExecutionResult, error)
	CaveInit(ctx context.Context, m *Managers, args *caveInitArgs, flags *caveInitFlags) (*ExecutionResult, error)
	CaveList(ctx context.Context, m *Managers, args *caveListArgs, flags *caveListFlags) (*ExecutionResult, error)
	CaveRun(ctx context.Context, m *Managers, args *caveRunArgs, flags *caveRunFlags) (*ExecutionResult, error)
	CaveSync(ctx context.Context, m *Managers, args *caveSyncArgs, flags *caveSyncFlags) (*ExecutionResult, error)
	CaveUse(ctx context.Context, m *Managers, args *caveUseArgs, flags *caveUseFlags) (*ExecutionResult, error)
	DiskClean(ctx context.Context, m *Managers, args *diskCleanArgs, flags *diskCleanFlags) (*ExecutionResult, error)
	DiskInfo(ctx context.Context, m *Managers, args *diskInfoArgs, flags *diskInfoFlags) (*ExecutionResult, error)
	DiskUninstall(ctx context.Context, m *Managers, args *diskUninstallArgs, flags *diskUninstallFlags) (*ExecutionResult, error)
	PkgInstall(ctx context.Context, m *Managers, args *pkgInstallArgs, flags *pkgInstallFlags) (*ExecutionResult, error)
	PkgList(ctx context.Context, m *Managers, args *pkgListArgs, flags *pkgListFlags) (*ExecutionResult, error)
	RecipeRepl(ctx context.Context, m *Managers, args *recipeReplArgs, flags *recipeReplFlags) (*ExecutionResult, error)
	RepoAdd(ctx context.Context, m *Managers, args *repoAddArgs, flags *repoAddFlags) (*ExecutionResult, error)
	RepoList(ctx context.Context, m *Managers, args *repoListArgs, flags *repoListFlags) (*ExecutionResult, error)
	Version(ctx context.Context, m *Managers, args *versionArgs, flags *versionFlags) (*ExecutionResult, error)
}

var cliGlobalFlags = []*flagDef{
	{Name: "verbose", Short: "v", Type: "bool", Desc: "Enable verbose output"},
	{Name: "config", Short: "c", Type: "string", Desc: "Path to config file"},
}

var cliTopics = []*topicDef{
	{Name: "about", Desc: "Overview", Text: " pi is a universal, workspace-based package installer that manages dependencies\n across multiple ecosystems (Node.js, Go, Java, etc.) using isolated sandboxes.\n It ensures deterministic environments without polluting your host system."},
	{Name: "architecture", Desc: "Architecture & Patterns", Text: " pi is built for safety and speed using the following patterns:\n - Immutability: Core structures use ReadOnly/Writable interfaces to prevent accidental mutation.\n - Pipeline: Installation follows a strict Resolve -> Download -> Install -> Reify flow.\n - Concurrency: Go's goroutines are used for parallel downloads and extractions."},
	{Name: "caves", Desc: "The Cave Sandbox", Text: " A 'Cave' is an isolated environment powered by Linux bubblewrap.\n - Isolation: Restricts filesystem access to the workspace and a private HOME.\n - Zero Pollution: Tools installed for one project do not affect the host or other projects.\n - Redirected Home: Environment variables (GOPATH, CARGO_HOME) are redirected into the Cave."},
	{Name: "workspace", Desc: "Workspace & Manifests", Text: " Workspaces are managed via the 'pi.cave.json' manifest.\n - Symlink Forest: pi populates .local/bin in the Cave Home with symlinks to the package cache.\n - Variants: Support for different environment configurations (e.g., 'legacy' or 'testing')\n within the same workspace."},
	{Name: "versions", Desc: "Version Formats & Queries", Text: " pi supports flexible versioning schemes and semantic keywords for package resolution.\n\n Keywords:\n - latest:  (Default) Resolves to the most recent version available.\n - stable:  Resolves to the latest release marked as stable by the upstream provider.\n - lts:     (Node.js/Java) Resolves to the latest Long Term Support release.\n\n Formats:\n - exact:   pi pkg install nodejs@20.11.0\n - prefix:  pi pkg install nodejs@20 (matches 20.*)\n - ecosys:  pi pkg install npm:typescript@latest (explicit ecosystem)"},
	{Name: "recipes", Desc: "Starlark Recipes", Text: " Recipes describe how packages are discovered and installed.\n - Language: Written in Starlark (a Python dialect).\n - Pure: Recipes are declarative and perform no direct I/O.\n - Discovery: Recipes return a 'DiscoveryRequest' for the host to fetch, then parse the response."},
}

var cliCommands = buildCommands()

func buildCommands() []*commandDef {
	cmdVersion := &commandDef{Name: "version", Desc: "Show version information", SafeInCave: true}
	cmdPkg := &commandDef{Name: "pkg", Desc: "Manage packages", SafeInCave: false}
	cmdPkgInstall := &commandDef{Name: "install", Desc: "Install a package", SafeInCave: false, Parent: cmdPkg, Args: []*argDef{{Name: "package", Type: "string", Desc: "Package name and version (e.g., nodejs@20)"}}, Flags: []*flagDef{{Name: "force", Short: "f", Type: "bool", Desc: "Force reinstallation"}}, Examples: []string{"pi pkg install nodejs@20", "pi pkg i nodejs@latest"}}
	cmdPkgList := &commandDef{Name: "list", Desc: "List available versions for a package", SafeInCave: false, Parent: cmdPkg, Args: []*argDef{{Name: "package", Type: "string", Desc: "Package name (e.g. go)"}}, Flags: []*flagDef{{Name: "all", Short: "a", Type: "bool", Desc: "Show all architectures/OSs"}, {Name: "index", Short: "i", Type: "bool", Desc: "List registry patterns only"}}, Examples: []string{"pi pkg list go"}}
	cmdRecipe := &commandDef{Name: "recipe", Desc: "Recipe development", SafeInCave: false}
	cmdRecipeRepl := &commandDef{Name: "repl", Desc: "Run the recipe development REPL", SafeInCave: false, Parent: cmdRecipe, Args: []*argDef{{Name: "file", Type: "string", Desc: "Path to recipe file"}}, Examples: []string{"pi recipe repl ./recipes/nodejs.star"}}
	cmdCave := &commandDef{Name: "cave", Desc: "Manage the cave (sandbox)", SafeInCave: false}
	cmdCaveInfo := &commandDef{Name: "info", Desc: "Display information about the current cave", SafeInCave: true, Parent: cmdCave, Examples: []string{"pi cave info"}}
	cmdCaveList := &commandDef{Name: "list", Desc: "List all registered caves and their variants", SafeInCave: false, Parent: cmdCave, Examples: []string{"pi cave list"}}
	cmdCaveUse := &commandDef{Name: "use", Desc: "Start a cave by name from any directory", SafeInCave: false, Parent: cmdCave, Args: []*argDef{{Name: "cave", Type: "string", Desc: "Cave name and optional variant (e.g., project:dev)"}}, Examples: []string{"pi cave use myproject", "pi cave use myproject:dev"}}
	cmdCaveRun := &commandDef{Name: "run", Desc: "Run a command inside the cave", SafeInCave: false, Parent: cmdCave, Args: []*argDef{{Name: "command", Type: "string", Desc: "Command to run"}}, Flags: []*flagDef{{Name: "variant", Short: "v", Type: "string", Desc: "Variant to use"}}, Examples: []string{"pi cave run ls", "pi cave run -v test go test ./..."}}
	cmdCaveSync := &commandDef{Name: "sync", Desc: "Sync all packages in pi.cave.json", SafeInCave: false, Parent: cmdCave, Examples: []string{"pi cave sync"}}
	cmdCaveInit := &commandDef{Name: "init", Desc: "Initialize a new workspace", SafeInCave: false, Parent: cmdCave, Examples: []string{"pi cave init"}}
	cmdCaveAddpkg := &commandDef{Name: "addpkg", Desc: "Add a package to the cave configuration", SafeInCave: false, Parent: cmdCave, Args: []*argDef{{Name: "package", Type: "string", Desc: "Package name and version (e.g., go=stable)"}}, Examples: []string{"pi cave addpkg go=stable"}}
	cmdCaveEnter := &commandDef{Name: "enter", Desc: "Enter the sandbox shell", SafeInCave: false, Parent: cmdCave, Examples: []string{"pi cave enter", "pi enter"}}
	cmdDisk := &commandDef{Name: "disk", Desc: "Manage local storage", SafeInCave: false}
	cmdDiskInfo := &commandDef{Name: "info", Desc: "Show disk usage summary", SafeInCave: false, Parent: cmdDisk, Examples: []string{"pi disk info"}}
	cmdDiskClean := &commandDef{Name: "clean", Desc: "Remove all cached data (packages, downloads, discovery cache)", SafeInCave: false, Parent: cmdDisk, Examples: []string{"pi disk clean"}}
	cmdDiskUninstall := &commandDef{Name: "uninstall", Desc: "Wipe all pi data (cache, state, and config)", SafeInCave: false, Parent: cmdDisk, Flags: []*flagDef{{Name: "force", Short: "f", Type: "bool", Desc: "Skip confirmation prompt"}}, Examples: []string{"pi disk uninstall"}}
	cmdRepo := &commandDef{Name: "repo", Desc: "Manage repositories", SafeInCave: false}
	cmdRepoList := &commandDef{Name: "list", Desc: "List all repositories", SafeInCave: false, Parent: cmdRepo, Examples: []string{"pi repo list", "pi list"}}
	cmdRepoAdd := &commandDef{Name: "add", Desc: "Add a new repository", SafeInCave: false, Parent: cmdRepo, Args: []*argDef{{Name: "name", Type: "string", Desc: "Name of the repository"}, {Name: "url", Type: "string", Desc: "URL of the repository"}}, Examples: []string{"pi repo add official https://github.com/google/pi-recipes"}}
	cmdHelp := &commandDef{Name: "help", Desc: "Show help information", SafeInCave: true}
	cmdPkg.Subs = []*commandDef{cmdPkgInstall, cmdPkgList}
	cmdRecipe.Subs = []*commandDef{cmdRecipeRepl}
	cmdCave.Subs = []*commandDef{cmdCaveInfo, cmdCaveList, cmdCaveUse, cmdCaveRun, cmdCaveSync, cmdCaveInit, cmdCaveAddpkg, cmdCaveEnter}
	cmdDisk.Subs = []*commandDef{cmdDiskInfo, cmdDiskClean, cmdDiskUninstall}
	cmdRepo.Subs = []*commandDef{cmdRepoList, cmdRepoAdd}
	return []*commandDef{cmdVersion, cmdPkg, cmdRecipe, cmdCave, cmdDisk, cmdRepo, cmdHelp}
}

type invocation struct {
	Command *commandDef
	Args    map[string]string
	Flags   map[string]any
}

func Parse(h Handlers, args []string) (Action, error) {
	if h == nil {
		return nil, fmt.Errorf("handlers is nil")
	}
	var gf globalFlags
	var remaining []string
	help := false
	for i := 0; i < len(args); i++ {
		arg := args[i]
		if arg == "--help" || arg == "-h" {
			help = true
			continue
		}
		found := false
		for _, f := range cliGlobalFlags {
			if arg == "--"+f.Name || (f.Short != "" && arg == "-"+f.Short) {
				found = true
				if f.Type == "bool" {
					applyGlobalFlag(&gf, f.Name, true)
				} else if f.Type == "string" && i+1 < len(args) {
					applyGlobalFlag(&gf, f.Name, args[i+1])
					i++
				}
			}
		}
		if !found {
			remaining = append(remaining, arg)
		}
	}
	if help || len(remaining) == 0 {
		return helpAction(remaining), nil
	}
	if remaining[0] == "help" {
		return helpAction(remaining[1:]), nil
	}
	inv := &invocation{Args: make(map[string]string), Flags: make(map[string]any)}
	finalInv, err := resolve(inv, cliCommands, remaining)
	if err != nil {
		return nil, err
	}
	if finalInv == nil || finalInv.Command == nil {
		return nil, fmt.Errorf("no command resolved")
	}
	if env := os.Getenv("PI_CAVENAME"); env != "" && !finalInv.Command.SafeInCave {
		return nil, fmt.Errorf("already in cave %s", env)
	}
	path := getCmdPath(finalInv.Command)
	switch path {
	case "cave/addpkg":
		args := &caveAddpkgArgs{}
		args.Package = finalInv.Args["package"]
		flags := &caveAddpkgFlags{}
		flags.globalFlags = gf
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &flags.globalFlags)
			return h.CaveAddpkg(ctx, m, args, flags)
		}, nil
	case "cave/enter":
		args := &caveEnterArgs{}
		flags := &caveEnterFlags{}
		flags.globalFlags = gf
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &flags.globalFlags)
			return h.CaveEnter(ctx, m, args, flags)
		}, nil
	case "cave/info":
		args := &caveInfoArgs{}
		flags := &caveInfoFlags{}
		flags.globalFlags = gf
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &flags.globalFlags)
			return h.CaveInfo(ctx, m, args, flags)
		}, nil
	case "cave/init":
		args := &caveInitArgs{}
		flags := &caveInitFlags{}
		flags.globalFlags = gf
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &flags.globalFlags)
			return h.CaveInit(ctx, m, args, flags)
		}, nil
	case "cave/list":
		args := &caveListArgs{}
		flags := &caveListFlags{}
		flags.globalFlags = gf
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &flags.globalFlags)
			return h.CaveList(ctx, m, args, flags)
		}, nil
	case "cave/run":
		args := &caveRunArgs{}
		args.Command = finalInv.Args["command"]
		flags := &caveRunFlags{}
		flags.globalFlags = gf
		flags.Variant = stringFlag(finalInv.Flags, "variant")
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &flags.globalFlags)
			return h.CaveRun(ctx, m, args, flags)
		}, nil
	case "cave/sync":
		args := &caveSyncArgs{}
		flags := &caveSyncFlags{}
		flags.globalFlags = gf
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &flags.globalFlags)
			return h.CaveSync(ctx, m, args, flags)
		}, nil
	case "cave/use":
		args := &caveUseArgs{}
		args.Cave = finalInv.Args["cave"]
		flags := &caveUseFlags{}
		flags.globalFlags = gf
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &flags.globalFlags)
			return h.CaveUse(ctx, m, args, flags)
		}, nil
	case "disk/clean":
		args := &diskCleanArgs{}
		flags := &diskCleanFlags{}
		flags.globalFlags = gf
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &flags.globalFlags)
			return h.DiskClean(ctx, m, args, flags)
		}, nil
	case "disk/info":
		args := &diskInfoArgs{}
		flags := &diskInfoFlags{}
		flags.globalFlags = gf
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &flags.globalFlags)
			return h.DiskInfo(ctx, m, args, flags)
		}, nil
	case "disk/uninstall":
		args := &diskUninstallArgs{}
		flags := &diskUninstallFlags{}
		flags.globalFlags = gf
		flags.Force = boolFlag(finalInv.Flags, "force")
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &flags.globalFlags)
			return h.DiskUninstall(ctx, m, args, flags)
		}, nil
	case "pkg/install":
		args := &pkgInstallArgs{}
		args.Package = finalInv.Args["package"]
		flags := &pkgInstallFlags{}
		flags.globalFlags = gf
		flags.Force = boolFlag(finalInv.Flags, "force")
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &flags.globalFlags)
			return h.PkgInstall(ctx, m, args, flags)
		}, nil
	case "pkg/list":
		args := &pkgListArgs{}
		args.Package = finalInv.Args["package"]
		flags := &pkgListFlags{}
		flags.globalFlags = gf
		flags.All = boolFlag(finalInv.Flags, "all")
		flags.Index = boolFlag(finalInv.Flags, "index")
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &flags.globalFlags)
			return h.PkgList(ctx, m, args, flags)
		}, nil
	case "recipe/repl":
		args := &recipeReplArgs{}
		args.File = finalInv.Args["file"]
		flags := &recipeReplFlags{}
		flags.globalFlags = gf
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &flags.globalFlags)
			return h.RecipeRepl(ctx, m, args, flags)
		}, nil
	case "repo/add":
		args := &repoAddArgs{}
		args.Name = finalInv.Args["name"]
		args.Url = finalInv.Args["url"]
		flags := &repoAddFlags{}
		flags.globalFlags = gf
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &flags.globalFlags)
			return h.RepoAdd(ctx, m, args, flags)
		}, nil
	case "repo/list":
		args := &repoListArgs{}
		flags := &repoListFlags{}
		flags.globalFlags = gf
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &flags.globalFlags)
			return h.RepoList(ctx, m, args, flags)
		}, nil
	case "version":
		args := &versionArgs{}
		flags := &versionFlags{}
		flags.globalFlags = gf
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &flags.globalFlags)
			return h.Version(ctx, m, args, flags)
		}, nil
	case "help":
		return helpAction(nil), nil
	default:
		return nil, fmt.Errorf("no handler for command: %s", path)
	}
}

func helpAction(args []string) Action {
	return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
		printHelp(args...)
		return &ExecutionResult{ExitCode: 0}, nil
	}
}

func applyGlobalFlag(g *globalFlags, name string, val any) {
	switch name {
	case "verbose":
		if b, ok := val.(bool); ok {
			g.Verbose = b
		}
	case "config":
		if s, ok := val.(string); ok {
			g.Config = s
		}
	}
}

func applyGlobalFlags(m *Managers, g *globalFlags) {
	if g.Verbose {
		m.Disp.SetVerbose(true)
	}
}

func boolFlag(flags map[string]any, name string) bool {
	if v, ok := flags[name]; ok {
		if b, ok := v.(bool); ok {
			return b
		}
	}
	return false
}

func stringFlag(flags map[string]any, name string) string {
	if v, ok := flags[name]; ok {
		if s, ok := v.(string); ok {
			return s
		}
	}
	return ""
}

func resolve(inv *invocation, cmds []*commandDef, args []string) (*invocation, error) {
	word := args[0]
	var matches []*commandDef
	for _, c := range cmds {
		if c.Name == word {
			matches = []*commandDef{c}
			break
		}
		if strings.HasPrefix(c.Name, word) {
			matches = append(matches, c)
		}
	}
	if len(matches) > 1 {
		var names []string
		for _, m := range matches {
			names = append(names, m.Name)
		}
		return nil, fmt.Errorf("ambiguous command: %s (candidates: %s)", word, strings.Join(names, ", "))
	}
	if len(matches) == 1 {
		cmd := matches[0]
		currArgs := args[1:]
		if len(currArgs) > 0 && (currArgs[0] == "--help" || currArgs[0] == "-h") {
			return nil, fmt.Errorf("help requested for %s", cmd.Name)
		}
		if len(currArgs) > 0 && len(cmd.Subs) > 0 {
			subInv, err := resolve(inv, cmd.Subs, currArgs)
			if err == nil {
				return subInv, nil
			}
			if !strings.HasPrefix(err.Error(), "unknown command") {
				return nil, err
			}
		}
		if len(cmd.Subs) > 0 {
			return nil, fmt.Errorf("unknown command: %s %s", cmd.Name, currArgs[0])
		}
		inv.Command = cmd
		if err := parseParams(inv, cmd, currArgs); err != nil {
			return nil, err
		}
		return inv, nil
	}
	if len(cmds) == len(cliCommands) {
		var subMatches []*commandDef
		for _, c := range cmds {
			for _, s := range c.Subs {
				if s.Name == word || strings.HasPrefix(s.Name, word) {
					subMatches = append(subMatches, s)
				}
			}
		}
		if len(subMatches) > 1 {
			var names []string
			for _, m := range subMatches {
				names = append(names, getCmdPath(m))
			}
			return nil, fmt.Errorf("ambiguous command: %s (candidates: %s)", word, strings.Join(names, ", "))
		}
		if len(subMatches) == 1 {
			s := subMatches[0]
			inv.Command = s
			if err := parseParams(inv, s, args[1:]); err != nil {
				return nil, err
			}
			return inv, nil
		}
	}
	return nil, fmt.Errorf("unknown command: %s", word)
}

func parseParams(inv *invocation, cmd *commandDef, args []string) error {
	argIdx := 0
	for i := 0; i < len(args); i++ {
		arg := args[i]
		if strings.HasPrefix(arg, "-") {
			found := false
			for _, f := range cmd.Flags {
				if arg == "--"+f.Name || (f.Short != "" && arg == "-"+f.Short) {
					if f.Type == "bool" {
						inv.Flags[f.Name] = true
						found = true
					} else if f.Type == "string" && i+1 < len(args) {
						inv.Flags[f.Name] = args[i+1]
						i++
						found = true
					}
					break
				}
			}
			if !found {
				if argIdx < len(cmd.Args) {
					inv.Args[cmd.Args[argIdx].Name] = arg
					argIdx++
				}
			}
		} else {
			if argIdx < len(cmd.Args) {
				inv.Args[cmd.Args[argIdx].Name] = arg
				argIdx++
			}
		}
	}
	if argIdx < len(cmd.Args) {
		if len(cmd.Args) == 1 && cmd.Parent != nil && cmd.Parent.Name == "pkg" && cmd.Name == "list" {
			if v, ok := inv.Flags["index"]; ok {
				if b, ok := v.(bool); ok && b {
					return nil
				}
			}
		}
		return fmt.Errorf("argument %s is missing", cmd.Args[argIdx].Name)
	}
	return nil
}

func printHelp(args ...string) {
	t := DefaultTheme()
	if len(args) > 0 {
		subject := args[0]
		for _, topic := range cliTopics {
			if topic.Name == subject || strings.HasPrefix(topic.Name, subject) {
				printTopicHelp(t, topic)
				return
			}
		}
		curr := cliCommands
		var found *commandDef
		for _, arg := range args {
			var match *commandDef
			for _, c := range curr {
				if c.Name == arg || strings.HasPrefix(c.Name, arg) {
					match = c
					break
				}
			}
			if match == nil {
				break
			}
			found = match
			curr = match.Subs
		}
		if found != nil {
			printCommandHelp(t, found)
			return
		}
	}
	fmt.Printf("%s\n", t.Styled(t.Cyan.Copy().Bold(true), "pi - Universal Package Installer"))
	fmt.Printf("\n%s\n", t.Styled(t.Bold, "Usage:"))
	fmt.Printf("  pi %s\n", t.Styled(t.Yellow, "[flags] <command>"))
	fmt.Printf("\n%s\n", t.Styled(t.Bold, "Global Flags:"))
	fmt.Printf("  %-12s %s\n", t.Styled(t.Cyan, "--help, -h"), t.Styled(t.Dim, "Show help [command | topic]"))
	for _, f := range cliGlobalFlags {
		short := ""
		if f.Short != "" {
			short = ", -" + f.Short
		}
		fmt.Printf("  %-12s %s\n", t.Styled(t.Cyan, "--"+f.Name+short), t.Styled(t.Dim, f.Desc))
	}
	categories := []struct {
		name string
		icon string
		cmds []string
	}{
		{"PACKAGE", t.IconPkg, []string{"pkg"}},
		{"CAVE", t.IconCave, []string{"cave"}},
		{"DISK", t.IconDisk, []string{"disk"}},
		{"REPO", t.IconWorld, []string{"repo"}},
	}
	shown := make(map[string]bool)
	fmt.Println()
	for _, cat := range categories {
		for _, name := range cat.cmds {
			for _, c := range cliCommands {
				if c.Name == name {
					printCommandTree(t, c, "", true, cat.icon)
					fmt.Println()
					shown[c.Name] = true
				}
			}
		}
	}
	var misc []*commandDef
	for _, c := range cliCommands {
		if !shown[c.Name] && c.Name != "help" {
			misc = append(misc, c)
		}
	}
	if len(misc) > 0 {
		fmt.Printf("%s %s\n", t.Bullet, t.Styled(t.Bold, "MISC"))
		for i, c := range misc {
			printCommandTree(t, c, "", i == len(misc)-1, "")
		}
		fmt.Println()
	}
	fmt.Printf("%s %s\n", t.IconHelp, t.Styled(t.Bold, "Topics:"))
	for _, topic := range cliTopics {
		name := t.Styled(t.Cyan, topic.Name)
		padding := getPadding(t, topic.Name, 20)
		fmt.Printf("  %s %s %s\n", name, padding, t.Styled(t.Dim, topic.Desc))
	}
	fmt.Printf("\nType '%s' for more details.\n", t.Styled(t.Yellow, "pi help <command>"))
}

func printCommandHelp(t *Theme, c *commandDef) {
	fmt.Printf("\n%s %s\n", t.Styled(t.Bold, "Command:"), t.Styled(t.Cyan, getCmdPath(c)))
	fmt.Printf("%s %s\n", t.Styled(t.Bold, "Description:"), t.Styled(t.Dim, c.Desc))
	fmt.Println()
	if len(c.Subs) > 0 {
		fmt.Printf("%s\n", t.Styled(t.Bold, "Subcommands:"))
		for i, s := range c.Subs {
			prefix := t.BoxTree
			if i == len(c.Subs)-1 {
				prefix = t.BoxLast
			}
			fmt.Printf("  %s %-12s %s\n", prefix, t.Styled(t.Cyan, s.Name), t.Styled(t.Dim, s.Desc))
		}
		fmt.Println()
	}
	if len(c.Args) > 0 {
		fmt.Printf("%s\n", t.Styled(t.Bold, "Arguments:"))
		for _, a := range c.Args {
			fmt.Printf("  %-15s %s\n", t.Styled(t.Yellow, "<"+a.Name+">"), t.Styled(t.Dim, a.Desc))
		}
		fmt.Println()
	}
	if len(c.Flags) > 0 {
		fmt.Printf("%s\n", t.Styled(t.Bold, "Flags:"))
		for _, f := range c.Flags {
			short := ""
			if f.Short != "" {
				short = ", -" + f.Short
			}
			fmt.Printf("  %-15s %s\n", t.Styled(t.Cyan, "--"+f.Name+short), t.Styled(t.Dim, f.Desc))
		}
		fmt.Println()
	}
	if len(c.Examples) > 0 {
		fmt.Printf("%s\n", t.Styled(t.Bold, "Examples:"))
		for _, ex := range c.Examples {
			fmt.Printf("  %s %s\n", t.Styled(t.Green, "$"), ex)
		}
		fmt.Println()
	}
}

func printTopicHelp(t *Theme, topic *topicDef) {
	fmt.Printf("\n%s %s\n", t.Styled(t.Bold, "Topic:"), t.Styled(t.Cyan, topic.Name))
	fmt.Printf("%s %s\n", t.Styled(t.Bold, "Description:"), t.Styled(t.Dim, topic.Desc))
	fmt.Println()
	fmt.Printf("%s\n\n", topic.Text)
}

func getPadding(t *Theme, name string, target int) string {
	dots := target - len(name)
	if dots < 2 {
		dots = 2
	}
	return t.Styled(t.Dim, strings.Repeat(".", dots))
}

func printCommandTree(t *Theme, c *commandDef, indent string, isLast bool, icon string) {
	prefix := t.BoxTree
	if isLast {
		prefix = t.BoxLast
	}
	namePart := indent + prefix + " "
	if icon != "" {
		namePart += icon + " "
	}
	namePart += t.Styled(t.Cyan, c.Name)
	visualLen := len(indent) + 4
	if icon != "" {
		visualLen += 3
	}
	visualLen += len(c.Name)
	padding := getPadding(t, strings.Repeat(" ", visualLen), 30)
	line := fmt.Sprintf("%s %s %s", namePart, padding, t.Styled(t.Dim, c.Desc))
	fmt.Println(line)
	newIndent := indent
	if isLast {
		newIndent += "    "
	} else {
		newIndent += t.BoxItem + " "
	}
	for i, s := range c.Subs {
		printCommandTree(t, s, newIndent, i == len(c.Subs)-1, "")
	}
}

func getCmdPath(c *commandDef) string {
	if c.Parent == nil {
		return c.Name
	}
	return getCmdPath(c.Parent) + "/" + c.Name
}
