// Code generated by cligen; DO NOT EDIT.

package cli

import (
	"fmt"
	"os"
	"strings"
)

func boolFlag(flags map[string]any, name string) bool {
	if v, ok := flags[name]; ok {
		if b, ok := v.(bool); ok {
			return b
		}
	}
	return false
}

func stringFlag(flags map[string]any, name string) string {
	if v, ok := flags[name]; ok {
		if s, ok := v.(string); ok {
			return s
		}
	}
	return ""
}

func resolve(inv *invocation, cmds []*commandDef, args []string) (*invocation, error) {
	word := args[0]
	var matches []*commandDef
	for _, c := range cmds {
		if c.Name == word {
			matches = []*commandDef{c}
			break
		}
		if strings.HasPrefix(c.Name, word) {
			matches = append(matches, c)
		}
	}
	if len(matches) > 1 {
		var names []string
		for _, m := range matches {
			names = append(names, m.Name)
		}
		return nil, fmt.Errorf("ambiguous command: %s (candidates: %s)", word, strings.Join(names, ", "))
	}
	if len(matches) == 1 {
		cmd := matches[0]
		currArgs := args[1:]
		if len(currArgs) > 0 && (currArgs[0] == "--help" || currArgs[0] == "-h") {
			return nil, fmt.Errorf("help requested for %s", cmd.Name)
		}
		if len(currArgs) > 0 && len(cmd.Subs) > 0 {
			subInv, err := resolve(inv, cmd.Subs, currArgs)
			if err == nil {
				return subInv, nil
			}
			if !strings.HasPrefix(err.Error(), "unknown command") {
				return nil, err
			}
		}
		if len(cmd.Subs) > 0 {
			return nil, fmt.Errorf("unknown command: %s %s", cmd.Name, currArgs[0])
		}
		inv.Command = cmd
		if err := parseParams(inv, cmd, currArgs); err != nil {
			return nil, err
		}
		return inv, nil
	}
	if len(cmds) == len(cliCommands) {
		var subMatches []*commandDef
		for _, c := range cmds {
			for _, s := range c.Subs {
				if s.Name == word || strings.HasPrefix(s.Name, word) {
					subMatches = append(subMatches, s)
				}
			}
		}
		if len(subMatches) > 1 {
			var names []string
			for _, m := range subMatches {
				names = append(names, getCmdPath(m))
			}
			return nil, fmt.Errorf("ambiguous command: %s (candidates: %s)", word, strings.Join(names, ", "))
		}
		if len(subMatches) == 1 {
			s := subMatches[0]
			inv.Command = s
			if err := parseParams(inv, s, args[1:]); err != nil {
				return nil, err
			}
			return inv, nil
		}
	}
	return nil, fmt.Errorf("unknown command: %s", word)
}

func parseParams(inv *invocation, cmd *commandDef, args []string) error {
	argIdx := 0
	for i := 0; i < len(args); i++ {
		arg := args[i]
		if strings.HasPrefix(arg, "-") {
			found := false
			for _, f := range cmd.Flags {
				if arg == "--"+f.Name || (f.Short != "" && arg == "-"+f.Short) {
					if f.Type == "bool" {
						inv.Flags[f.Name] = true
						found = true
					} else if f.Type == "string" && i+1 < len(args) {
						inv.Flags[f.Name] = args[i+1]
						i++
						found = true
					}
					break
				}
			}
			if !found {
				if argIdx < len(cmd.Args) {
					inv.Args[cmd.Args[argIdx].Name] = arg
					argIdx++
				}
			}
		} else {
			if argIdx < len(cmd.Args) {
				inv.Args[cmd.Args[argIdx].Name] = arg
				argIdx++
			}
		}
	}
	if argIdx < len(cmd.Args) {
		if len(cmd.Args) == 1 && cmd.Parent != nil && cmd.Parent.Name == "pkg" && cmd.Name == "list" {
			if v, ok := inv.Flags["index"]; ok {
				if b, ok := v.(bool); ok && b {
					return nil
				}
			}
		}
		return fmt.Errorf("argument %s is missing", cmd.Args[argIdx].Name)
	}
	return nil
}

type helpData struct {
	Topic       *topicDef
	Command     *commandDef
	Root        *rootHelpData
	CommandPath string
}

type rootHelpData struct {
	GlobalFlags []*flagDef
	Topics      []*topicDef
	Commands    []*commandDef
	Name        string
	Tagline     string
}

func printHelp(args ...string) {
	if len(args) > 0 {
		subject := args[0]
		for _, topic := range cliTopics {
			if topic.Name == subject || strings.HasPrefix(topic.Name, subject) {
				renderHelp(&helpData{Topic: topic})
				return
			}
		}
		curr := cliCommands
		var found *commandDef
		for _, arg := range args {
			var match *commandDef
			for _, c := range curr {
				if c.Name == arg || strings.HasPrefix(c.Name, arg) {
					match = c
					break
				}
			}
			if match == nil {
				break
			}
			found = match
			curr = match.Subs
		}
		if found != nil {
			renderHelp(&helpData{Command: found, CommandPath: getCmdPath(found)})
			return
		}
	}

	var cmds []*commandDef
	for _, c := range cliCommands {
		if c.Name == "help" {
			continue
		}
		cmds = append(cmds, c)
	}

	renderHelp(&helpData{Root: &rootHelpData{
		GlobalFlags: cliGlobalFlags,
		Topics:      cliTopics,
		Commands:    cmds,
		Name:        cliAppName,
		Tagline:     cliTagline,
	}})
}

func renderHelp(data *helpData) {
	var b strings.Builder
	switch {
	case data.Topic != nil:
		fmt.Fprintf(&b, "Topic: %s\nDescription: %s\n\n%s\n", data.Topic.Name, data.Topic.Desc, data.Topic.Text)
	case data.Command != nil:
		fmt.Fprintf(&b, "Command: %s\nDescription: %s\n\n", data.CommandPath, data.Command.Desc)
		if len(data.Command.Subs) > 0 {
			b.WriteString("Subcommands:\n")
			for _, sub := range data.Command.Subs {
				fmt.Fprintf(&b, "  %s    %s\n", sub.Name, sub.Desc)
			}
			b.WriteString("\n")
		}
		if len(data.Command.Args) > 0 {
			b.WriteString("Arguments:\n")
			for _, arg := range data.Command.Args {
				fmt.Fprintf(&b, "  <%s>    %s\n", arg.Name, arg.Desc)
			}
			b.WriteString("\n")
		}
		if len(data.Command.Flags) > 0 {
			b.WriteString("Flags:\n")
			for _, flag := range data.Command.Flags {
				fmt.Fprintf(&b, "  --%s", flag.Name)
				if flag.Short != "" {
					fmt.Fprintf(&b, ", -%s", flag.Short)
				}
				fmt.Fprintf(&b, "    %s\n", flag.Desc)
			}
			b.WriteString("\n")
		}
		if len(data.Command.Examples) > 0 {
			b.WriteString("Examples:\n")
			for _, ex := range data.Command.Examples {
				fmt.Fprintf(&b, "  $ %s\n", ex)
			}
		}
	default:
		writeRootHelp(&b, data.Root)
	}
	if _, err := os.Stdout.WriteString(b.String()); err != nil {
		fmt.Fprintf(os.Stderr, "help render error: %v\n", err)
	}
}

func writeRootHelp(b *strings.Builder, root *rootHelpData) {
	if root == nil {
		return
	}
	name := "<program>"
	if root.Name != "" {
		name = root.Name
		fmt.Fprintf(b, "%s : %s\n\n", root.Name, root.Tagline)
	}
	fmt.Fprintf(b, "Usage:\n  %s [flags] <command>\n\n", name)
	b.WriteString("Global Flags:\n")
	b.WriteString("  --help, -h    Show help [command | topic]\n")
	for _, flag := range root.GlobalFlags {
		fmt.Fprintf(b, "  --%s", flag.Name)
		if flag.Short != "" {
			fmt.Fprintf(b, ", -%s", flag.Short)
		}
		fmt.Fprintf(b, "    %s\n", flag.Desc)
	}
	b.WriteString("\nCommands:\n")
	for _, cmd := range root.Commands {
		fmt.Fprintf(b, "  %s    %s\n", cmd.Name, cmd.Desc)
		if len(cmd.Subs) > 0 {
			b.WriteString("    Subcommands:\n")
			for _, sub := range cmd.Subs {
				fmt.Fprintf(b, "      %s    %s\n", sub.Name, sub.Desc)
			}
		}
	}
	if len(root.Topics) > 0 {
		b.WriteString("\nTopics:\n")
		for _, topic := range root.Topics {
			fmt.Fprintf(b, "  %s    %s\n", topic.Name, topic.Desc)
		}
	}
	fmt.Fprintf(b, "\nType '%s help <command>' for more details.\n", name)
}

func getCmdPath(c *commandDef) string {
	if c.Parent == nil {
		return c.Name
	}
	return getCmdPath(c.Parent) + "/" + c.Name
}
