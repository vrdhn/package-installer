// Code generated by cligen; DO NOT EDIT.

package cli

import (
	"fmt"
	"os"
	"strings"
)

type flagDef struct {
	Name  string
	Short string
	Type  string
	Desc  string
}

type argDef struct {
	Name string
	Type string
	Desc string
}

type commandDef struct {
	Name     string
	Desc     string
	Safe     bool
	Args     []*argDef
	Flags    []*flagDef
	Subs     []*commandDef
	Parent   *commandDef
	Examples []string
}

type topicDef struct {
	Name string
	Desc string
	Text string
}

type globalFlags struct {
	Verbose bool
	Config  string
}

type caveAddpkgParams struct {
	globalFlags
	Package string
}

type caveEnterParams struct {
	globalFlags
	_ struct{}
}

type caveInfoParams struct {
	globalFlags
	_ struct{}
}

type caveInitParams struct {
	globalFlags
	_ struct{}
}

type caveListParams struct {
	globalFlags
	_ struct{}
}

type caveRunParams struct {
	globalFlags
	Command string
	Variant string
}

type caveSyncParams struct {
	globalFlags
	_ struct{}
}

type caveUseParams struct {
	globalFlags
	Cave string
}

type diskCleanParams struct {
	globalFlags
	_ struct{}
}

type diskInfoParams struct {
	globalFlags
	_ struct{}
}

type diskUninstallParams struct {
	globalFlags
	Force bool
}

type pkgInstallParams struct {
	globalFlags
	Package string
	Force   bool
}

type pkgListParams struct {
	globalFlags
	Package string
	All     bool
	Index   bool
}

type recipeReplParams struct {
	globalFlags
	File string
}

type repoAddParams struct {
	globalFlags
	Name string
	Url  string
}

type repoListParams struct {
	globalFlags
	_ struct{}
}

type versionParams struct {
	globalFlags
	_ struct{}
}

type Handlers interface {
	CaveAddpkg(params *caveAddpkgParams) Action
	CaveEnter(params *caveEnterParams) Action
	CaveInfo(params *caveInfoParams) Action
	CaveInit(params *caveInitParams) Action
	CaveList(params *caveListParams) Action
	CaveRun(params *caveRunParams) Action
	CaveSync(params *caveSyncParams) Action
	CaveUse(params *caveUseParams) Action
	DiskClean(params *diskCleanParams) Action
	DiskInfo(params *diskInfoParams) Action
	DiskUninstall(params *diskUninstallParams) Action
	PkgInstall(params *pkgInstallParams) Action
	PkgList(params *pkgListParams) Action
	RecipeRepl(params *recipeReplParams) Action
	RepoAdd(params *repoAddParams) Action
	RepoList(params *repoListParams) Action
	Version(params *versionParams) Action
}

var cliGlobalFlags = []*flagDef{
	{Name: "verbose", Short: "v", Type: "bool", Desc: "Enable verbose output"},
	{Name: "config", Short: "c", Type: "string", Desc: "Path to config file"},
}

var cliTopics = []*topicDef{
	{Name: "about", Desc: "Overview", Text: " pi is a universal, workspace-based package installer that manages dependencies\n across multiple ecosystems (Node.js, Go, Java, etc.) using isolated sandboxes.\n It ensures deterministic environments without polluting your host system."},
	{Name: "architecture", Desc: "Architecture & Patterns", Text: " pi is built for safety and speed using the following patterns:\n - Immutability: Core structures use ReadOnly/Writable interfaces to prevent accidental mutation.\n - Pipeline: Installation follows a strict Resolve -> Download -> Install -> Reify flow.\n - Concurrency: Go's goroutines are used for parallel downloads and extractions."},
	{Name: "caves", Desc: "The Cave Sandbox", Text: " A 'Cave' is an isolated environment powered by Linux bubblewrap.\n - Isolation: Restricts filesystem access to the workspace and a private HOME.\n - Zero Pollution: Tools installed for one project do not affect the host or other projects.\n - Redirected Home: Environment variables (GOPATH, CARGO_HOME) are redirected into the Cave."},
	{Name: "workspace", Desc: "Workspace & Manifests", Text: " Workspaces are managed via the 'pi.cave.json' manifest.\n - Symlink Forest: pi populates .local/bin in the Cave Home with symlinks to the package cache.\n - Variants: Support for different environment configurations (e.g., 'legacy' or 'testing')\n within the same workspace."},
	{Name: "versions", Desc: "Version Formats & Queries", Text: " pi supports flexible versioning schemes and semantic keywords for package resolution.\n\n Keywords:\n - latest:  (Default) Resolves to the most recent version available.\n - stable:  Resolves to the latest release marked as stable by the upstream provider.\n - lts:     (Node.js/Java) Resolves to the latest Long Term Support release.\n\n Formats:\n - exact:   pi pkg install nodejs@20.11.0\n - prefix:  pi pkg install nodejs@20 (matches 20.*)\n - ecosys:  pi pkg install npm:typescript@latest (explicit ecosystem)"},
	{Name: "recipes", Desc: "Starlark Recipes", Text: " Recipes describe how packages are discovered and installed.\n - Language: Written in Starlark (a Python dialect).\n - Pure: Recipes are declarative and perform no direct I/O.\n - Discovery: Recipes return a 'DiscoveryRequest' for the host to fetch, then parse the response."},
}

var cliCommands = buildCommands()
var cliAppName = "pi"
var cliTagline = "Universal package installer for isolated workspaces"

func buildCommands() []*commandDef {
	cmdVersion := &commandDef{Name: "version", Desc: "Show version information", Safe: true}
	cmdPkg := &commandDef{Name: "pkg", Desc: "Manage packages", Safe: false}
	cmdPkgInstall := &commandDef{Name: "install", Desc: "Install a package", Parent: cmdPkg, Safe: false, Args: []*argDef{{Name: "package", Type: "string", Desc: "Package name and version (e.g., nodejs@20)"}}, Flags: []*flagDef{{Name: "force", Short: "f", Type: "bool", Desc: "Force reinstallation"}}, Examples: []string{"pi pkg install nodejs@20", "pi pkg i nodejs@latest"}}
	cmdPkgList := &commandDef{Name: "list", Desc: "List available versions for a package", Parent: cmdPkg, Safe: false, Args: []*argDef{{Name: "package", Type: "string", Desc: "Package name (e.g. go)"}}, Flags: []*flagDef{{Name: "all", Short: "a", Type: "bool", Desc: "Show all architectures/OSs"}, {Name: "index", Short: "i", Type: "bool", Desc: "List registry patterns only"}}, Examples: []string{"pi pkg list go"}}
	cmdRecipe := &commandDef{Name: "recipe", Desc: "Recipe development", Safe: false}
	cmdRecipeRepl := &commandDef{Name: "repl", Desc: "Run the recipe development REPL", Parent: cmdRecipe, Safe: false, Args: []*argDef{{Name: "file", Type: "string", Desc: "Path to recipe file"}}, Examples: []string{"pi recipe repl ./recipes/nodejs.star"}}
	cmdCave := &commandDef{Name: "cave", Desc: "Manage the cave (sandbox)", Safe: false}
	cmdCaveInfo := &commandDef{Name: "info", Desc: "Display information about the current cave", Parent: cmdCave, Safe: true, Examples: []string{"pi cave info"}}
	cmdCaveList := &commandDef{Name: "list", Desc: "List all registered caves and their variants", Parent: cmdCave, Safe: false, Examples: []string{"pi cave list"}}
	cmdCaveUse := &commandDef{Name: "use", Desc: "Start a cave by name from any directory", Parent: cmdCave, Safe: false, Args: []*argDef{{Name: "cave", Type: "string", Desc: "Cave name and optional variant (e.g., project:dev)"}}, Examples: []string{"pi cave use myproject", "pi cave use myproject:dev"}}
	cmdCaveRun := &commandDef{Name: "run", Desc: "Run a command inside the cave", Parent: cmdCave, Safe: false, Args: []*argDef{{Name: "command", Type: "string", Desc: "Command to run"}}, Flags: []*flagDef{{Name: "variant", Short: "v", Type: "string", Desc: "Variant to use"}}, Examples: []string{"pi cave run ls", "pi cave run -v test go test ./..."}}
	cmdCaveSync := &commandDef{Name: "sync", Desc: "Sync all packages in pi.cave.json", Parent: cmdCave, Safe: false, Examples: []string{"pi cave sync"}}
	cmdCaveInit := &commandDef{Name: "init", Desc: "Initialize a new workspace", Parent: cmdCave, Safe: false, Examples: []string{"pi cave init"}}
	cmdCaveAddpkg := &commandDef{Name: "addpkg", Desc: "Add a package to the cave configuration", Parent: cmdCave, Safe: false, Args: []*argDef{{Name: "package", Type: "string", Desc: "Package name and version (e.g., go=stable)"}}, Examples: []string{"pi cave addpkg go=stable"}}
	cmdCaveEnter := &commandDef{Name: "enter", Desc: "Enter the sandbox shell", Parent: cmdCave, Safe: false, Examples: []string{"pi cave enter", "pi enter"}}
	cmdDisk := &commandDef{Name: "disk", Desc: "Manage local storage", Safe: false}
	cmdDiskInfo := &commandDef{Name: "info", Desc: "Show disk usage summary", Parent: cmdDisk, Safe: false, Examples: []string{"pi disk info"}}
	cmdDiskClean := &commandDef{Name: "clean", Desc: "Remove all cached data (packages, downloads, discovery cache)", Parent: cmdDisk, Safe: false, Examples: []string{"pi disk clean"}}
	cmdDiskUninstall := &commandDef{Name: "uninstall", Desc: "Wipe all pi data (cache, state, and config)", Parent: cmdDisk, Safe: false, Flags: []*flagDef{{Name: "force", Short: "f", Type: "bool", Desc: "Skip confirmation prompt"}}, Examples: []string{"pi disk uninstall"}}
	cmdRepo := &commandDef{Name: "repo", Desc: "Manage repositories", Safe: false}
	cmdRepoList := &commandDef{Name: "list", Desc: "List all repositories", Parent: cmdRepo, Safe: false, Examples: []string{"pi repo list", "pi list"}}
	cmdRepoAdd := &commandDef{Name: "add", Desc: "Add a new repository", Parent: cmdRepo, Safe: false, Args: []*argDef{{Name: "name", Type: "string", Desc: "Name of the repository"}, {Name: "url", Type: "string", Desc: "URL of the repository"}}, Examples: []string{"pi repo add official https://github.com/google/pi-recipes"}}
	cmdHelp := &commandDef{Name: "help", Desc: "Show help information", Safe: true}
	cmdPkg.Subs = []*commandDef{cmdPkgInstall, cmdPkgList}
	cmdRecipe.Subs = []*commandDef{cmdRecipeRepl}
	cmdCave.Subs = []*commandDef{cmdCaveInfo, cmdCaveList, cmdCaveUse, cmdCaveRun, cmdCaveSync, cmdCaveInit, cmdCaveAddpkg, cmdCaveEnter}
	cmdDisk.Subs = []*commandDef{cmdDiskInfo, cmdDiskClean, cmdDiskUninstall}
	cmdRepo.Subs = []*commandDef{cmdRepoList, cmdRepoAdd}

	return []*commandDef{cmdVersion, cmdPkg, cmdRecipe, cmdCave, cmdDisk, cmdRepo, cmdHelp}
}

type invocation struct {
	Command *commandDef
	Args    map[string]string
	Flags   map[string]any
}

func Parse(h Handlers, args []string) (Action, error) {
	if h == nil {
		return nil, fmt.Errorf("handlers is nil")
	}
	var gf globalFlags
	var remaining []string
	help := false
	for i := 0; i < len(args); i++ {
		arg := args[i]
		if arg == "--help" || arg == "-h" {
			help = true
			continue
		}
		found := false
		for _, f := range cliGlobalFlags {
			if arg == "--"+f.Name || (f.Short != "" && arg == "-"+f.Short) {
				found = true
				if f.Type == "bool" {
					applyGlobalFlag(&gf, f.Name, true)
				} else if f.Type == "string" && i+1 < len(args) {
					applyGlobalFlag(&gf, f.Name, args[i+1])
					i++
				}
			}
		}
		if !found {
			remaining = append(remaining, arg)
		}
	}
	if help || len(remaining) == 0 {
		return helpAction(remaining), nil
	}
	if remaining[0] == "help" {
		return helpAction(remaining[1:]), nil
	}
	inv := &invocation{Args: make(map[string]string), Flags: make(map[string]any)}
	finalInv, err := resolve(inv, cliCommands, remaining)
	if err != nil {
		return nil, err
	}
	if finalInv == nil || finalInv.Command == nil {
		return nil, fmt.Errorf("no command resolved")
	}
	path := getCmdPath(finalInv.Command)
	switch path {
	case "cave/addpkg":
		params := &caveAddpkgParams{}
		params.Package = finalInv.Args["package"]
		params.globalFlags = gf
		action := h.CaveAddpkg(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "cave/enter":
		params := &caveEnterParams{}
		params.globalFlags = gf
		action := h.CaveEnter(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "cave/info":
		params := &caveInfoParams{}
		params.globalFlags = gf
		action := h.CaveInfo(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "cave/init":
		params := &caveInitParams{}
		params.globalFlags = gf
		action := h.CaveInit(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "cave/list":
		params := &caveListParams{}
		params.globalFlags = gf
		action := h.CaveList(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "cave/run":
		params := &caveRunParams{}
		params.Command = finalInv.Args["command"]
		params.globalFlags = gf
		params.Variant = stringFlag(finalInv.Flags, "variant")
		action := h.CaveRun(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "cave/sync":
		params := &caveSyncParams{}
		params.globalFlags = gf
		action := h.CaveSync(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "cave/use":
		params := &caveUseParams{}
		params.Cave = finalInv.Args["cave"]
		params.globalFlags = gf
		action := h.CaveUse(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "disk/clean":
		params := &diskCleanParams{}
		params.globalFlags = gf
		action := h.DiskClean(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "disk/info":
		params := &diskInfoParams{}
		params.globalFlags = gf
		action := h.DiskInfo(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "disk/uninstall":
		params := &diskUninstallParams{}
		params.globalFlags = gf
		params.Force = boolFlag(finalInv.Flags, "force")
		action := h.DiskUninstall(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "pkg/install":
		params := &pkgInstallParams{}
		params.Package = finalInv.Args["package"]
		params.globalFlags = gf
		params.Force = boolFlag(finalInv.Flags, "force")
		action := h.PkgInstall(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "pkg/list":
		params := &pkgListParams{}
		params.Package = finalInv.Args["package"]
		params.globalFlags = gf
		params.All = boolFlag(finalInv.Flags, "all")
		params.Index = boolFlag(finalInv.Flags, "index")
		action := h.PkgList(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "recipe/repl":
		params := &recipeReplParams{}
		params.File = finalInv.Args["file"]
		params.globalFlags = gf
		action := h.RecipeRepl(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "repo/add":
		params := &repoAddParams{}
		params.Name = finalInv.Args["name"]
		params.Url = finalInv.Args["url"]
		params.globalFlags = gf
		action := h.RepoAdd(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "repo/list":
		params := &repoListParams{}
		params.globalFlags = gf
		action := h.RepoList(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "version":
		params := &versionParams{}
		params.globalFlags = gf
		action := h.Version(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "help":
		return helpAction(nil), nil
	default:
		return nil, fmt.Errorf("no handler for command: %s", path)
	}
}

func helpAction(args []string) Action {
	return func() (*ExecutionResult, error) {
		printHelp(args...)
		return &ExecutionResult{ExitCode: 0}, nil
	}
}

func applyGlobalFlag(g *globalFlags, name string, val any) {
	switch name {
	case "verbose":
		if b, ok := val.(bool); ok {
			g.Verbose = b
		}
	case "config":
		if s, ok := val.(string); ok {
			g.Config = s
		}
	}
}
