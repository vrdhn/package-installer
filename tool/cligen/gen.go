package main

import (
	"bytes"
	"go/format"
	"sort"
	"text/template"
)

type genData struct {
	Pkg         string
	GlobalFlags []*defFlag
	Topics      []*defTopic
	Commands    []*defCommand
	AllCommands []*defCommand
	Leafs       []*defCommand
	ParamDefs   []paramDef
	HasSafe     bool
	CmdVarName  map[*defCommand]string
}

func generate(def *defFile, pkgName string) ([]byte, error) {
	paramDefs, err := collectParamDefs(def)
	if err != nil {
		return nil, err
	}

	leafs := collectLeafCommands(def.Commands)
	sort.Slice(leafs, func(i, j int) bool { return cmdPath(leafs[i]) < cmdPath(leafs[j]) })

	cmdVars := map[*defCommand]string{}
	var all []*defCommand
	walkCommands(def.Commands, func(c *defCommand) {
		all = append(all, c)
	})

	helpCmd := &defCommand{Name: "help", Desc: "Show help information", Params: map[string]paramValue{"safe": {Kind: "bool", Bool: true}}}
	topCommands := append(append([]*defCommand{}, def.Commands...), helpCmd)
	all = append(all, helpCmd)

	for _, c := range all {
		cmdVars[c] = "cmd" + goNameForPath(cmdPath(c))
	}

	data := genData{
		Pkg:         pkgName,
		GlobalFlags: def.GlobalFlags,
		Topics:      def.Topics,
		Commands:    topCommands,
		AllCommands: all,
		Leafs:       leafs,
		ParamDefs:   paramDefs,
		HasSafe:     hasParam(paramDefs, "safe"),
		CmdVarName:  cmdVars,
	}

	funcs := template.FuncMap{
		"goFieldName":    goFieldName,
		"goTypeForParam": goTypeForParam,
		"goTypeForFlag":  goTypeForFlag,
		"goTypeForArg":   goTypeForArg,
		"lowerFirst":     lowerFirst,
		"goNameForPath":  goNameForPath,
		"cmdPath":        cmdPath,
		"cmdVar": func(c *defCommand) string {
			return cmdVars[c]
		},
		"paramLiteral": func(cmd *defCommand, name string, kind string) string {
			val, _ := resolveParam(def, cmd, name)
			return emitParamLiteral(val, kind)
		},
	}

	tmpl, err := template.New("cli").Funcs(funcs).Parse(cliTemplate)
	if err != nil {
		return nil, err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, err
	}
	return formatted, nil
}

const cliTemplate = `// Code generated by cligen; DO NOT EDIT.

package {{.Pkg}}

import (
	"context"
	"fmt"
	"strings"
)

type flagDef struct {
	Name  string
	Short string
	Type  string
	Desc  string
}

type argDef struct {
	Name string
	Type string
	Desc string
}

type commandDef struct {
	Name string
	Desc string
{{- range .ParamDefs }}
	{{ goFieldName .Name }} {{ goTypeForParam .Kind }}
{{- end }}
	Args     []*argDef
	Flags    []*flagDef
	Subs     []*commandDef
	Parent   *commandDef
	Examples []string
}

type topicDef struct {
	Name string
	Desc string
	Text string
}

func (c *commandDef) IsSafe() bool {
{{- if .HasSafe }}
	return c.Safe
{{- else }}
	return false
{{- end }}
}

type globalFlags struct {
{{- range .GlobalFlags }}
	{{ goFieldName .Name }} {{ goTypeForFlag .Type }}
{{- end }}
{{- if eq (len .GlobalFlags) 0 }}
	_ struct{}
{{- end }}
}

{{- range .Leafs }}
{{- $base := lowerFirst (goNameForPath (cmdPath .)) }}

type {{ $base }}Params struct {
	globalFlags
{{- if .Args }}
{{- range .Args }}
	{{ goFieldName .Name }} {{ goTypeForArg .Type }}
{{- end }}
{{- end }}
{{- if .Flags }}
{{- range .Flags }}
	{{ goFieldName .Name }} {{ goTypeForFlag .Type }}
{{- end }}
{{- end }}
{{- if and (not .Args) (not .Flags) }}
	_ struct{}
{{- end }}
}
{{- end }}

type Handlers interface {
{{- range .Leafs }}
	{{ goNameForPath (cmdPath .) }}(params *{{ lowerFirst (goNameForPath (cmdPath .)) }}Params) Action
{{- end }}
}

var cliGlobalFlags = []*flagDef{
{{- range .GlobalFlags }}
	{Name: {{ printf "%q" .Name }}, Short: {{ printf "%q" .Short }}, Type: {{ printf "%q" .Type }}, Desc: {{ printf "%q" .Desc }}},
{{- end }}
}

var cliTopics = []*topicDef{
{{- range .Topics }}
	{Name: {{ printf "%q" .Name }}, Desc: {{ printf "%q" .Desc }}, Text: {{ printf "%q" .Text }}},
{{- end }}
}

var cliCommands = buildCommands()

func buildCommands() []*commandDef {
{{- range .AllCommands }}
{{- $c := . }}
	{{ cmdVar . }} := &commandDef{Name: {{ printf "%q" .Name }}, Desc: {{ printf "%q" .Desc }}{{- if .Parent }}, Parent: {{ cmdVar .Parent }}{{- end }}{{- range $p := $.ParamDefs }}, {{ goFieldName $p.Name }}: {{ paramLiteral $c $p.Name $p.Kind }}{{- end }}{{- if .Args }}, Args: []*argDef{ {{- range .Args }}{Name: {{ printf "%q" .Name }}, Type: {{ printf "%q" .Type }}, Desc: {{ printf "%q" .Desc }}},{{- end }} }{{- end }}{{- if .Flags }}, Flags: []*flagDef{ {{- range .Flags }}{Name: {{ printf "%q" .Name }}, Short: {{ printf "%q" .Short }}, Type: {{ printf "%q" .Type }}, Desc: {{ printf "%q" .Desc }}},{{- end }} }{{- end }}{{- if .Examples }}, Examples: []string{ {{- range .Examples }}{{ printf "%q" . }},{{- end }} }{{- end }} }
{{- end }}
{{- range .AllCommands }}
{{- if .Subs }}
	{{ cmdVar . }}.Subs = []*commandDef{ {{- range .Subs }}{{ cmdVar . }},{{- end }} }
{{- end }}
{{- end }}

	return []*commandDef{ {{- range .Commands }}{{ cmdVar . }},{{- end }} }
}

type invocation struct {
	Command *commandDef
	Args    map[string]string
	Flags   map[string]any
}

func Parse(h Handlers, args []string) (Action, error) {
	if h == nil {
		return nil, fmt.Errorf("handlers is nil")
	}
	var gf globalFlags
	var remaining []string
	help := false
	for i := 0; i < len(args); i++ {
		arg := args[i]
		if arg == "--help" || arg == "-h" {
			help = true
			continue
		}
		found := false
		for _, f := range cliGlobalFlags {
			if arg == "--"+f.Name || (f.Short != "" && arg == "-"+f.Short) {
				found = true
				if f.Type == "bool" {
					applyGlobalFlag(&gf, f.Name, true)
				} else if f.Type == "string" && i+1 < len(args) {
					applyGlobalFlag(&gf, f.Name, args[i+1])
					i++
				}
			}
		}
		if !found {
			remaining = append(remaining, arg)
		}
	}
	if help || len(remaining) == 0 {
		return helpAction(remaining), nil
	}
	if remaining[0] == "help" {
		return helpAction(remaining[1:]), nil
	}
	inv := &invocation{Args: make(map[string]string), Flags: make(map[string]any)}
	finalInv, err := resolve(inv, cliCommands, remaining)
	if err != nil {
		return nil, err
	}
	if finalInv == nil || finalInv.Command == nil {
		return nil, fmt.Errorf("no command resolved")
	}
	path := getCmdPath(finalInv.Command)
	switch path {
{{- range .Leafs }}
	case {{ printf "%q" (cmdPath .) }}:
		params := &{{ lowerFirst (goNameForPath (cmdPath .)) }}Params{}
{{- range .Args }}
		params.{{ goFieldName .Name }} = finalInv.Args[{{ printf "%q" .Name }}]
{{- end }}
		params.globalFlags = gf
{{- range .Flags }}
{{- if eq .Type "bool" }}
		params.{{ goFieldName .Name }} = boolFlag(finalInv.Flags, {{ printf "%q" .Name }})
{{- else if eq .Type "string" }}
		params.{{ goFieldName .Name }} = stringFlag(finalInv.Flags, {{ printf "%q" .Name }})
{{- end }}
{{- end }}
		action := h.{{ goNameForPath (cmdPath .) }}(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
			applyGlobalFlags(m, &params.globalFlags)
			return action(ctx, m)
		}, nil
{{- end }}
	case "help":
		return helpAction(nil), nil
	default:
		return nil, fmt.Errorf("no handler for command: %s", path)
	}
}

func helpAction(args []string) Action {
	return func(ctx context.Context, m *Managers) (*ExecutionResult, error) {
		printHelp(args...)
		return &ExecutionResult{ExitCode: 0}, nil
	}
}

func applyGlobalFlag(g *globalFlags, name string, val any) {
	switch name {
{{- range .GlobalFlags }}
	case {{ printf "%q" .Name }}:
{{- if eq .Type "bool" }}
		if b, ok := val.(bool); ok {
			g.{{ goFieldName .Name }} = b
		}
{{- else if eq .Type "string" }}
		if s, ok := val.(string); ok {
			g.{{ goFieldName .Name }} = s
		}
{{- end }}
{{- end }}
	}
}

func applyGlobalFlags(m *Managers, g *globalFlags) {
	if g.Verbose {
		m.Disp.SetVerbose(true)
	}
}

func boolFlag(flags map[string]any, name string) bool {
	if v, ok := flags[name]; ok {
		if b, ok := v.(bool); ok {
			return b
		}
	}
	return false
}

func stringFlag(flags map[string]any, name string) string {
	if v, ok := flags[name]; ok {
		if s, ok := v.(string); ok {
			return s
		}
	}
	return ""
}

func resolve(inv *invocation, cmds []*commandDef, args []string) (*invocation, error) {
	word := args[0]
	var matches []*commandDef
	for _, c := range cmds {
		if c.Name == word {
			matches = []*commandDef{c}
			break
		}
		if strings.HasPrefix(c.Name, word) {
			matches = append(matches, c)
		}
	}
	if len(matches) > 1 {
		var names []string
		for _, m := range matches {
			names = append(names, m.Name)
		}
		return nil, fmt.Errorf("ambiguous command: %s (candidates: %s)", word, strings.Join(names, ", "))
	}
	if len(matches) == 1 {
		cmd := matches[0]
		currArgs := args[1:]
		if len(currArgs) > 0 && (currArgs[0] == "--help" || currArgs[0] == "-h") {
			return nil, fmt.Errorf("help requested for %s", cmd.Name)
		}
		if len(currArgs) > 0 && len(cmd.Subs) > 0 {
			subInv, err := resolve(inv, cmd.Subs, currArgs)
			if err == nil {
				return subInv, nil
			}
			if !strings.HasPrefix(err.Error(), "unknown command") {
				return nil, err
			}
		}
		if len(cmd.Subs) > 0 {
			return nil, fmt.Errorf("unknown command: %s %s", cmd.Name, currArgs[0])
		}
		inv.Command = cmd
		if err := parseParams(inv, cmd, currArgs); err != nil {
			return nil, err
		}
		return inv, nil
	}
	if len(cmds) == len(cliCommands) {
		var subMatches []*commandDef
		for _, c := range cmds {
			for _, s := range c.Subs {
				if s.Name == word || strings.HasPrefix(s.Name, word) {
					subMatches = append(subMatches, s)
				}
			}
		}
		if len(subMatches) > 1 {
			var names []string
			for _, m := range subMatches {
				names = append(names, getCmdPath(m))
			}
			return nil, fmt.Errorf("ambiguous command: %s (candidates: %s)", word, strings.Join(names, ", "))
		}
		if len(subMatches) == 1 {
			s := subMatches[0]
			inv.Command = s
			if err := parseParams(inv, s, args[1:]); err != nil {
				return nil, err
			}
			return inv, nil
		}
	}
	return nil, fmt.Errorf("unknown command: %s", word)
}

func parseParams(inv *invocation, cmd *commandDef, args []string) error {
	argIdx := 0
	for i := 0; i < len(args); i++ {
		arg := args[i]
		if strings.HasPrefix(arg, "-") {
			found := false
			for _, f := range cmd.Flags {
				if arg == "--"+f.Name || (f.Short != "" && arg == "-"+f.Short) {
					if f.Type == "bool" {
						inv.Flags[f.Name] = true
						found = true
					} else if f.Type == "string" && i+1 < len(args) {
						inv.Flags[f.Name] = args[i+1]
						i++
						found = true
					}
					break
				}
			}
			if !found {
				if argIdx < len(cmd.Args) {
					inv.Args[cmd.Args[argIdx].Name] = arg
					argIdx++
				}
			}
		} else {
			if argIdx < len(cmd.Args) {
				inv.Args[cmd.Args[argIdx].Name] = arg
				argIdx++
			}
		}
	}
	if argIdx < len(cmd.Args) {
		if len(cmd.Args) == 1 && cmd.Parent != nil && cmd.Parent.Name == "pkg" && cmd.Name == "list" {
			if v, ok := inv.Flags["index"]; ok {
				if b, ok := v.(bool); ok && b {
					return nil
				}
			}
		}
		return fmt.Errorf("argument %s is missing", cmd.Args[argIdx].Name)
	}
	return nil
}

func printHelp(args ...string) {
	t := DefaultTheme()
	if len(args) > 0 {
		subject := args[0]
		for _, topic := range cliTopics {
			if topic.Name == subject || strings.HasPrefix(topic.Name, subject) {
				printTopicHelp(t, topic)
				return
			}
		}
		curr := cliCommands
		var found *commandDef
		for _, arg := range args {
			var match *commandDef
			for _, c := range curr {
				if c.Name == arg || strings.HasPrefix(c.Name, arg) {
					match = c
					break
				}
			}
			if match == nil {
				break
			}
			found = match
			curr = match.Subs
		}
		if found != nil {
			printCommandHelp(t, found)
			return
		}
	}
	fmt.Printf("%s\n", t.Styled(t.Cyan.Copy().Bold(true), "pi - Universal Package Installer"))
	fmt.Printf("\n%s\n", t.Styled(t.Bold, "Usage:"))
	fmt.Printf("  pi %s\n", t.Styled(t.Yellow, "[flags] <command>"))
	fmt.Printf("\n%s\n", t.Styled(t.Bold, "Global Flags:"))
	fmt.Printf("  %-12s %s\n", t.Styled(t.Cyan, "--help, -h"), t.Styled(t.Dim, "Show help [command | topic]"))
	for _, f := range cliGlobalFlags {
		short := ""
		if f.Short != "" {
			short = ", -" + f.Short
		}
		fmt.Printf("  %-12s %s\n", t.Styled(t.Cyan, "--"+f.Name+short), t.Styled(t.Dim, f.Desc))
	}
	categories := []struct {
		name string
		icon string
		cmds []string
	}{
		{"PACKAGE", t.IconPkg, []string{"pkg"}},
		{"CAVE", t.IconCave, []string{"cave"}},
		{"DISK", t.IconDisk, []string{"disk"}},
		{"REPO", t.IconWorld, []string{"repo"}},
	}
	shown := make(map[string]bool)
	fmt.Println()
	for _, cat := range categories {
		for _, name := range cat.cmds {
			for _, c := range cliCommands {
				if c.Name == name {
					printCommandTree(t, c, "", true, cat.icon)
					fmt.Println()
					shown[c.Name] = true
				}
			}
		}
	}
	var misc []*commandDef
	for _, c := range cliCommands {
		if !shown[c.Name] && c.Name != "help" {
			misc = append(misc, c)
		}
	}
	if len(misc) > 0 {
		fmt.Printf("%s %s\n", t.Bullet, t.Styled(t.Bold, "MISC"))
		for i, c := range misc {
			printCommandTree(t, c, "", i == len(misc)-1, "")
		}
		fmt.Println()
	}
	fmt.Printf("%s %s\n", t.IconHelp, t.Styled(t.Bold, "Topics:"))
	for _, topic := range cliTopics {
		name := t.Styled(t.Cyan, topic.Name)
		padding := getPadding(t, topic.Name, 20)
		fmt.Printf("  %s %s %s\n", name, padding, t.Styled(t.Dim, topic.Desc))
	}
	fmt.Printf("\nType '%s' for more details.\n", t.Styled(t.Yellow, "pi help <command>"))
}

func printCommandHelp(t *Theme, c *commandDef) {
	fmt.Printf("\n%s %s\n", t.Styled(t.Bold, "Command:"), t.Styled(t.Cyan, getCmdPath(c)))
	fmt.Printf("%s %s\n", t.Styled(t.Bold, "Description:"), t.Styled(t.Dim, c.Desc))
	fmt.Println()
	if len(c.Subs) > 0 {
		fmt.Printf("%s\n", t.Styled(t.Bold, "Subcommands:"))
		for i, s := range c.Subs {
			prefix := t.BoxTree
			if i == len(c.Subs)-1 {
				prefix = t.BoxLast
			}
			fmt.Printf("  %s %-12s %s\n", prefix, t.Styled(t.Cyan, s.Name), t.Styled(t.Dim, s.Desc))
		}
		fmt.Println()
	}
	if len(c.Args) > 0 {
		fmt.Printf("%s\n", t.Styled(t.Bold, "Arguments:"))
		for _, a := range c.Args {
			fmt.Printf("  %-15s %s\n", t.Styled(t.Yellow, "<"+a.Name+">"), t.Styled(t.Dim, a.Desc))
		}
		fmt.Println()
	}
	if len(c.Flags) > 0 {
		fmt.Printf("%s\n", t.Styled(t.Bold, "Flags:"))
		for _, f := range c.Flags {
			short := ""
			if f.Short != "" {
				short = ", -" + f.Short
			}
			fmt.Printf("  %-15s %s\n", t.Styled(t.Cyan, "--"+f.Name+short), t.Styled(t.Dim, f.Desc))
		}
		fmt.Println()
	}
	if len(c.Examples) > 0 {
		fmt.Printf("%s\n", t.Styled(t.Bold, "Examples:"))
		for _, ex := range c.Examples {
			fmt.Printf("  %s %s\n", t.Styled(t.Green, "$"), ex)
		}
		fmt.Println()
	}
}

func printTopicHelp(t *Theme, topic *topicDef) {
	fmt.Printf("\n%s %s\n", t.Styled(t.Bold, "Topic:"), t.Styled(t.Cyan, topic.Name))
	fmt.Printf("%s %s\n", t.Styled(t.Bold, "Description:"), t.Styled(t.Dim, topic.Desc))
	fmt.Println()
	fmt.Printf("%s\n\n", topic.Text)
}

func getPadding(t *Theme, name string, target int) string {
	dots := target - len(name)
	if dots < 2 {
		dots = 2
	}
	return t.Styled(t.Dim, strings.Repeat(".", dots))
}

func printCommandTree(t *Theme, c *commandDef, indent string, isLast bool, icon string) {
	prefix := t.BoxTree
	if isLast {
		prefix = t.BoxLast
	}
	namePart := indent + prefix + " "
	if icon != "" {
		namePart += icon + " "
	}
	namePart += t.Styled(t.Cyan, c.Name)
	visualLen := len(indent) + 4
	if icon != "" {
		visualLen += 3
	}
	visualLen += len(c.Name)
	padding := getPadding(t, strings.Repeat(" ", visualLen), 30)
	line := fmt.Sprintf("%s %s %s", namePart, padding, t.Styled(t.Dim, c.Desc))
	fmt.Println(line)
	newIndent := indent
	if isLast {
		newIndent += "    "
	} else {
		newIndent += t.BoxItem + " "
	}
	for i, s := range c.Subs {
		printCommandTree(t, s, newIndent, i == len(c.Subs)-1, "")
	}
}

func getCmdPath(c *commandDef) string {
	if c.Parent == nil {
		return c.Name
	}
	return getCmdPath(c.Parent) + "/" + c.Name
}
`
