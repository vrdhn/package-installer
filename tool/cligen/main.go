package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

type defFile struct {
	GlobalFlags []*defFlag
	Commands    []*defCommand
	Topics      []*defTopic
}

type defFlag struct {
	Name  string
	Short string
	Type  string
	Desc  string
}

type defArg struct {
	Name string
	Type string
	Desc string
}

type defCommand struct {
	Name       string
	Desc       string
	SafeInCave bool
	Args       []*defArg
	Flags      []*defFlag
	Subs       []*defCommand
	Parent     *defCommand
	Examples   []string
}

type defTopic struct {
	Name string
	Desc string
	Text string
}

func main() {
	if len(os.Args) != 3 {
		fmt.Fprintln(os.Stderr, "usage: cligen <path/to/file.def> <package>")
		os.Exit(2)
	}
	inPath := os.Args[1]
	pkgName := os.Args[2]
	inAbs, err := filepath.Abs(inPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "abs path for %s: %v\n", inPath, err)
		os.Exit(1)
	}
	fmt.Printf("Processing %s\n", inAbs)
	if filepath.Ext(inPath) != ".def" {
		fmt.Fprintf(os.Stderr, "input must be a .def file: %s\n", inPath)
		os.Exit(2)
	}
	content, err := os.ReadFile(inPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "read %s: %v\n", inPath, err)
		os.Exit(1)
	}
	def, err := parseDef(string(content))
	if err != nil {
		fmt.Fprintf(os.Stderr, "parse %s: %v\n", inPath, err)
		os.Exit(1)
	}

	outPath := strings.TrimSuffix(inPath, ".def") + ".go"
	outAbs, err := filepath.Abs(outPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "abs path for %s: %v\n", outPath, err)
		os.Exit(1)
	}
	fmt.Printf("Writing %s\n", outAbs)
	if !isValidIdent(pkgName) {
		fmt.Fprintf(os.Stderr, "invalid package name %q\n", pkgName)
		os.Exit(1)
	}

	src, err := generate(def, pkgName)
	if err != nil {
		fmt.Fprintf(os.Stderr, "generate: %v\n", err)
		os.Exit(1)
	}
	if err := os.WriteFile(outPath, src, 0o644); err != nil {
		fmt.Fprintf(os.Stderr, "write %s: %v\n", outPath, err)
		os.Exit(1)
	}
}

func generate(def *defFile, pkgName string) ([]byte, error) {
	var buf bytes.Buffer
	w := &buf
	write := func(format string, args ...any) {
		if len(args) == 0 {
			_, _ = io.WriteString(w, format)
			return
		}
		fmt.Fprintf(w, format, args...)
	}

	write("// Code generated by cligen; DO NOT EDIT.\n")
	write("\n")
	write("package %s\n", pkgName)
	write("\n")
	write("import (\n")
	write("\t\"context\"\n")
	write("\t\"fmt\"\n")
	write("\t\"os\"\n")
	write("\t\"strings\"\n")
	write(")\n\n")

	// Internal types
	write("type flagDef struct {\n")
	write("\tName string\n")
	write("\tShort string\n")
	write("\tType string\n")
	write("\tDesc string\n")
	write("}\n\n")

	write("type argDef struct {\n")
	write("\tName string\n")
	write("\tType string\n")
	write("\tDesc string\n")
	write("}\n\n")

	write("type commandDef struct {\n")
	write("\tName string\n")
	write("\tDesc string\n")
	write("\tSafeInCave bool\n")
	write("\tArgs []*argDef\n")
	write("\tFlags []*flagDef\n")
	write("\tSubs []*commandDef\n")
	write("\tParent *commandDef\n")
	write("\tExamples []string\n")
	write("}\n\n")

	write("type topicDef struct {\n")
	write("\tName string\n")
	write("\tDesc string\n")
	write("\tText string\n")
	write("}\n\n")

	// Global flags struct
	write("type globalFlags struct {\n")
	for _, f := range def.GlobalFlags {
		write("\t%s %s\n", goFieldName(f.Name), goTypeForFlag(f.Type))
	}
	if len(def.GlobalFlags) == 0 {
		write("\t_ struct{}\n")
	}
	write("}\n\n")

	// Command args/flags structs (leaf commands only)
	leafs := collectLeafCommands(def.Commands)
	sort.Slice(leafs, func(i, j int) bool { return cmdPath(leafs[i]) < cmdPath(leafs[j]) })
	for _, cmd := range leafs {
		base := lowerFirst(goNameForPath(cmdPath(cmd)))
		argsName := base + "Args"
		flagsName := base + "Flags"
		write("type %s struct {\n", argsName)
		if len(cmd.Args) == 0 {
			write("\t_ struct{}\n")
		} else {
			for _, a := range cmd.Args {
				write("\t%s %s\n", goFieldName(a.Name), goTypeForArg(a.Type))
			}
		}
		write("}\n\n")

		write("type %s struct {\n", flagsName)
		write("\tglobalFlags\n")
		if len(cmd.Flags) == 0 {
			write("\t_ struct{}\n")
		} else {
			for _, f := range cmd.Flags {
				write("\t%s %s\n", goFieldName(f.Name), goTypeForFlag(f.Type))
			}
		}
		write("}\n\n")
	}

	// Handlers interface
	write("type Handlers interface {\n")
	for _, cmd := range leafs {
		method := goNameForPath(cmdPath(cmd))
		argsName := lowerFirst(method) + "Args"
		flagsName := lowerFirst(method) + "Flags"
		write("\t%s(ctx context.Context, m *Managers, args *%s, flags *%s) (*ExecutionResult, error)\n", method, argsName, flagsName)
	}
	write("}\n\n")

	// Data tables
	write("var cliGlobalFlags = []*flagDef{\n")
	for _, f := range def.GlobalFlags {
		write("\t{Name: %q, Short: %q, Type: %q, Desc: %q},\n", f.Name, f.Short, f.Type, f.Desc)
	}
	write("}\n\n")

	write("var cliTopics = []*topicDef{\n")
	for _, t := range def.Topics {
		write("\t{Name: %q, Desc: %q, Text: %q},\n", t.Name, t.Desc, t.Text)
	}
	write("}\n\n")

	write("var cliCommands = buildCommands()\n\n")

	write("func buildCommands() []*commandDef {\n")
	cmdVars := map[*defCommand]string{}
	var all []*defCommand
	walkCommands(def.Commands, func(c *defCommand) {
		all = append(all, c)
	})
	// Add generated help command
	helpCmd := &defCommand{Name: "help", Desc: "Show help information", SafeInCave: true}
	def.Commands = append(def.Commands, helpCmd)
	all = append(all, helpCmd)
	for _, c := range all {
		cmdVars[c] = "cmd" + goNameForPath(cmdPath(c))
	}
	for _, c := range all {
		name := cmdVars[c]
		write("\t%s := &commandDef{Name: %q, Desc: %q, SafeInCave: %v", name, c.Name, c.Desc, c.SafeInCave)
		if c.Parent != nil {
			write(", Parent: %s", cmdVars[c.Parent])
		}
		if len(c.Args) > 0 {
			write(", Args: []*argDef{")
			for _, a := range c.Args {
				write("{Name: %q, Type: %q, Desc: %q},", a.Name, a.Type, a.Desc)
			}
			write("}")
		}
		if len(c.Flags) > 0 {
			write(", Flags: []*flagDef{")
			for _, f := range c.Flags {
				write("{Name: %q, Short: %q, Type: %q, Desc: %q},", f.Name, f.Short, f.Type, f.Desc)
			}
			write("}")
		}
		if len(c.Examples) > 0 {
			write(", Examples: []string{")
			for _, ex := range c.Examples {
				write("%q,", ex)
			}
			write("}")
		}
		write("}\n")
	}
	// Subs wiring
	for _, c := range all {
		if len(c.Subs) == 0 {
			continue
		}
		write("\t%s.Subs = []*commandDef{", cmdVars[c])
		for _, s := range c.Subs {
			write("%s,", cmdVars[s])
		}
		write("}\n")
	}

	write("\treturn []*commandDef{")
	for _, c := range def.Commands {
		write("%s,", cmdVars[c])
	}
	write("}\n")
	write("}\n\n")

	// Parse and helpers
	write("type invocation struct {\n")
	write("\tCommand *commandDef\n")
	write("\tArgs map[string]string\n")
	write("\tFlags map[string]any\n")
	write("}\n\n")

	write("func Parse(h Handlers, args []string) (Action, error) {\n")
	write("\tif h == nil {\n")
	write("\t\treturn nil, fmt.Errorf(\"handlers is nil\")\n")
	write("\t}\n")
	write("\tvar gf globalFlags\n")
	write("\tvar remaining []string\n")
	write("\thelp := false\n")
	write("\tfor i := 0; i < len(args); i++ {\n")
	write("\t\targ := args[i]\n")
	write("\t\tif arg == \"--help\" || arg == \"-h\" {\n")
	write("\t\t\thelp = true\n")
	write("\t\t\tcontinue\n")
	write("\t\t}\n")
	write("\t\tfound := false\n")
	write("\t\tfor _, f := range cliGlobalFlags {\n")
	write("\t\t\tif arg == \"--\"+f.Name || (f.Short != \"\" && arg == \"-\"+f.Short) {\n")
	write("\t\t\t\tfound = true\n")
	write("\t\t\t\tif f.Type == \"bool\" {\n")
	write("\t\t\t\t\tapplyGlobalFlag(&gf, f.Name, true)\n")
	write("\t\t\t\t} else if f.Type == \"string\" && i+1 < len(args) {\n")
	write("\t\t\t\t\tapplyGlobalFlag(&gf, f.Name, args[i+1])\n")
	write("\t\t\t\t\ti++\n")
	write("\t\t\t\t}\n")
	write("\t\t\t}\n")
	write("\t\t}\n")
	write("\t\tif !found {\n")
	write("\t\t\tremaining = append(remaining, arg)\n")
	write("\t\t}\n")
	write("\t}\n")
	write("\tif help || len(remaining) == 0 {\n")
	write("\t\treturn helpAction(remaining), nil\n")
	write("\t}\n")
	write("\tif remaining[0] == \"help\" {\n")
	write("\t\treturn helpAction(remaining[1:]), nil\n")
	write("\t}\n")
	write("\tinv := &invocation{Args: make(map[string]string), Flags: make(map[string]any)}\n")
	write("\tfinalInv, err := resolve(inv, cliCommands, remaining)\n")
	write("\tif err != nil {\n")
	write("\t\treturn nil, err\n")
	write("\t}\n")
	write("\tif finalInv == nil || finalInv.Command == nil {\n")
	write("\t\treturn nil, fmt.Errorf(\"no command resolved\")\n")
	write("\t}\n")
	write("\tif env := os.Getenv(\"PI_CAVENAME\"); env != \"\" && !finalInv.Command.SafeInCave {\n")
	write("\t\treturn nil, fmt.Errorf(\"already in cave %s\", env)\n")
	write("\t}\n")
	write("\tpath := getCmdPath(finalInv.Command)\n")
	write("\tswitch path {\n")
	for _, cmd := range leafs {
		method := goNameForPath(cmdPath(cmd))
		argsName := lowerFirst(method) + "Args"
		flagsName := lowerFirst(method) + "Flags"
		write("\tcase %q:\n", cmdPath(cmd))
		write("\t\targs := &%s{}\n", argsName)
		for _, a := range cmd.Args {
			write("\t\targs.%s = finalInv.Args[%q]\n", goFieldName(a.Name), a.Name)
		}
		write("\t\tflags := &%s{}\n", flagsName)
		write("\t\tflags.globalFlags = gf\n")
		for _, f := range cmd.Flags {
			if f.Type == "bool" {
				write("\t\tflags.%s = boolFlag(finalInv.Flags, %q)\n", goFieldName(f.Name), f.Name)
			} else if f.Type == "string" {
				write("\t\tflags.%s = stringFlag(finalInv.Flags, %q)\n", goFieldName(f.Name), f.Name)
			}
		}
		write("\t\treturn func(ctx context.Context, m *Managers) (*ExecutionResult, error) {\n")
		write("\t\t\tapplyGlobalFlags(m, &flags.globalFlags)\n")
		write("\t\t\treturn h.%s(ctx, m, args, flags)\n", method)
		write("\t\t}, nil\n")
	}
	write("\tcase %q:\n", "help")
	write("\t\treturn helpAction(nil), nil\n")
	write("\tdefault:\n")
	write("\t\treturn nil, fmt.Errorf(\"no handler for command: %s\", path)\n")
	write("\t}\n")
	write("}\n\n")

	write("func helpAction(args []string) Action {\n")
	write("\treturn func(ctx context.Context, m *Managers) (*ExecutionResult, error) {\n")
	write("\t\tprintHelp(args...)\n")
	write("\t\treturn &ExecutionResult{ExitCode: 0}, nil\n")
	write("\t}\n")
	write("}\n\n")

	write("func applyGlobalFlag(g *globalFlags, name string, val any) {\n")
	write("\tswitch name {\n")
	for _, f := range def.GlobalFlags {
		field := goFieldName(f.Name)
		write("\tcase %q:\n", f.Name)
		if f.Type == "bool" {
			write("\t\tif b, ok := val.(bool); ok {\n")
			write("\t\t\tg.%s = b\n", field)
			write("\t\t}\n")
		} else if f.Type == "string" {
			write("\t\tif s, ok := val.(string); ok {\n")
			write("\t\t\tg.%s = s\n", field)
			write("\t\t}\n")
		}
	}
	write("\t}\n")
	write("}\n\n")

	write("func applyGlobalFlags(m *Managers, g *globalFlags) {\n")
	write("\tif g.Verbose {\n")
	write("\t\tm.Disp.SetVerbose(true)\n")
	write("\t}\n")
	write("}\n\n")

	write("func boolFlag(flags map[string]any, name string) bool {\n")
	write("\tif v, ok := flags[name]; ok {\n")
	write("\t\tif b, ok := v.(bool); ok {\n")
	write("\t\t\treturn b\n")
	write("\t\t}\n")
	write("\t}\n")
	write("\treturn false\n")
	write("}\n\n")

	write("func stringFlag(flags map[string]any, name string) string {\n")
	write("\tif v, ok := flags[name]; ok {\n")
	write("\t\tif s, ok := v.(string); ok {\n")
	write("\t\t\treturn s\n")
	write("\t\t}\n")
	write("\t}\n")
	write("\treturn \"\"\n")
	write("}\n\n")

	write("func resolve(inv *invocation, cmds []*commandDef, args []string) (*invocation, error) {\n")
	write("\tword := args[0]\n")
	write("\tvar matches []*commandDef\n")
	write("\tfor _, c := range cmds {\n")
	write("\t\tif c.Name == word {\n")
	write("\t\t\tmatches = []*commandDef{c}\n")
	write("\t\t\tbreak\n")
	write("\t\t}\n")
	write("\t\tif strings.HasPrefix(c.Name, word) {\n")
	write("\t\t\tmatches = append(matches, c)\n")
	write("\t\t}\n")
	write("\t}\n")
	write("\tif len(matches) > 1 {\n")
	write("\t\tvar names []string\n")
	write("\t\tfor _, m := range matches {\n")
	write("\t\t\tnames = append(names, m.Name)\n")
	write("\t\t}\n")
	write("\t\treturn nil, fmt.Errorf(\"ambiguous command: %s (candidates: %s)\", word, strings.Join(names, \", \") )\n")
	write("\t}\n")
	write("\tif len(matches) == 1 {\n")
	write("\t\tcmd := matches[0]\n")
	write("\t\tcurrArgs := args[1:]\n")
	write("\t\tif len(currArgs) > 0 && (currArgs[0] == \"--help\" || currArgs[0] == \"-h\") {\n")
	write("\t\t\treturn nil, fmt.Errorf(\"help requested for %s\", cmd.Name)\n")
	write("\t\t}\n")
	write("\t\tif len(currArgs) > 0 && len(cmd.Subs) > 0 {\n")
	write("\t\t\tsubInv, err := resolve(inv, cmd.Subs, currArgs)\n")
	write("\t\t\tif err == nil {\n")
	write("\t\t\t\treturn subInv, nil\n")
	write("\t\t\t}\n")
	write("\t\t\tif !strings.HasPrefix(err.Error(), \"unknown command\") {\n")
	write("\t\t\t\treturn nil, err\n")
	write("\t\t\t}\n")
	write("\t\t}\n")
	write("\t\tif len(cmd.Subs) > 0 {\n")
	write("\t\t\treturn nil, fmt.Errorf(\"unknown command: %s %s\", cmd.Name, currArgs[0])\n")
	write("\t\t}\n")
	write("\t\tinv.Command = cmd\n")
	write("\t\tif err := parseParams(inv, cmd, currArgs); err != nil {\n")
	write("\t\t\treturn nil, err\n")
	write("\t\t}\n")
	write("\t\treturn inv, nil\n")
	write("\t}\n")
	write("\tif len(cmds) == len(cliCommands) {\n")
	write("\t\tvar subMatches []*commandDef\n")
	write("\t\tfor _, c := range cmds {\n")
	write("\t\t\tfor _, s := range c.Subs {\n")
	write("\t\t\t\tif s.Name == word || strings.HasPrefix(s.Name, word) {\n")
	write("\t\t\t\t\tsubMatches = append(subMatches, s)\n")
	write("\t\t\t\t}\n")
	write("\t\t\t}\n")
	write("\t\t}\n")
	write("\t\tif len(subMatches) > 1 {\n")
	write("\t\t\tvar names []string\n")
	write("\t\t\tfor _, m := range subMatches {\n")
	write("\t\t\t\tnames = append(names, getCmdPath(m))\n")
	write("\t\t\t}\n")
	write("\t\t\treturn nil, fmt.Errorf(\"ambiguous command: %s (candidates: %s)\", word, strings.Join(names, \", \") )\n")
	write("\t\t}\n")
	write("\t\tif len(subMatches) == 1 {\n")
	write("\t\t\ts := subMatches[0]\n")
	write("\t\t\tinv.Command = s\n")
	write("\t\t\tif err := parseParams(inv, s, args[1:]); err != nil {\n")
	write("\t\t\t\treturn nil, err\n")
	write("\t\t\t}\n")
	write("\t\t\treturn inv, nil\n")
	write("\t\t}\n")
	write("\t}\n")
	write("\treturn nil, fmt.Errorf(\"unknown command: %s\", word)\n")
	write("}\n\n")

	write("func parseParams(inv *invocation, cmd *commandDef, args []string) error {\n")
	write("\targIdx := 0\n")
	write("\tfor i := 0; i < len(args); i++ {\n")
	write("\t\targ := args[i]\n")
	write("\t\tif strings.HasPrefix(arg, \"-\") {\n")
	write("\t\t\tfound := false\n")
	write("\t\t\tfor _, f := range cmd.Flags {\n")
	write("\t\t\t\tif arg == \"--\"+f.Name || (f.Short != \"\" && arg == \"-\"+f.Short) {\n")
	write("\t\t\t\t\tif f.Type == \"bool\" {\n")
	write("\t\t\t\t\t\tinv.Flags[f.Name] = true\n")
	write("\t\t\t\t\t\tfound = true\n")
	write("\t\t\t\t\t} else if f.Type == \"string\" && i+1 < len(args) {\n")
	write("\t\t\t\t\t\tinv.Flags[f.Name] = args[i+1]\n")
	write("\t\t\t\t\t\ti++\n")
	write("\t\t\t\t\t\tfound = true\n")
	write("\t\t\t\t\t}\n")
	write("\t\t\t\t\tbreak\n")
	write("\t\t\t\t}\n")
	write("\t\t\t}\n")
	write("\t\t\tif !found {\n")
	write("\t\t\t\tif argIdx < len(cmd.Args) {\n")
	write("\t\t\t\t\tinv.Args[cmd.Args[argIdx].Name] = arg\n")
	write("\t\t\t\t\targIdx++\n")
	write("\t\t\t\t}\n")
	write("\t\t\t}\n")
	write("\t\t} else {\n")
	write("\t\t\tif argIdx < len(cmd.Args) {\n")
	write("\t\t\t\tinv.Args[cmd.Args[argIdx].Name] = arg\n")
	write("\t\t\t\targIdx++\n")
	write("\t\t\t}\n")
	write("\t\t}\n")
	write("\t}\n")
	write("\tif argIdx < len(cmd.Args) {\n")
	write("\t\tif len(cmd.Args) == 1 && cmd.Parent != nil && cmd.Parent.Name == \"pkg\" && cmd.Name == \"list\" {\n")
	write("\t\t\tif v, ok := inv.Flags[\"index\"]; ok {\n")
	write("\t\t\t\tif b, ok := v.(bool); ok && b {\n")
	write("\t\t\t\t\treturn nil\n")
	write("\t\t\t\t}\n")
	write("\t\t\t}\n")
	write("\t\t}\n")
	write("\t\treturn fmt.Errorf(\"argument %s is missing\", cmd.Args[argIdx].Name)\n")
	write("\t}\n")
	write("\treturn nil\n")
	write("}\n\n")

	// Help
	write("func printHelp(args ...string) {\n")
	write("\tt := DefaultTheme()\n")
	write("\tif len(args) > 0 {\n")
	write("\t\tsubject := args[0]\n")
	write("\t\tfor _, topic := range cliTopics {\n")
	write("\t\t\tif topic.Name == subject || strings.HasPrefix(topic.Name, subject) {\n")
	write("\t\t\t\tprintTopicHelp(t, topic)\n")
	write("\t\t\t\treturn\n")
	write("\t\t\t}\n")
	write("\t\t}\n")
	write("\t\tcurr := cliCommands\n")
	write("\t\tvar found *commandDef\n")
	write("\t\tfor _, arg := range args {\n")
	write("\t\t\tvar match *commandDef\n")
	write("\t\t\tfor _, c := range curr {\n")
	write("\t\t\t\tif c.Name == arg || strings.HasPrefix(c.Name, arg) {\n")
	write("\t\t\t\t\tmatch = c\n")
	write("\t\t\t\t\tbreak\n")
	write("\t\t\t\t}\n")
	write("\t\t\t}\n")
	write("\t\t\tif match == nil {\n")
	write("\t\t\t\tbreak\n")
	write("\t\t\t}\n")
	write("\t\t\tfound = match\n")
	write("\t\t\tcurr = match.Subs\n")
	write("\t\t}\n")
	write("\t\tif found != nil {\n")
	write("\t\t\tprintCommandHelp(t, found)\n")
	write("\t\t\treturn\n")
	write("\t\t}\n")
	write("\t}\n")
	write("\tfmt.Printf(\"%s\\n\", t.Styled(t.Cyan.Copy().Bold(true), \"pi - Universal Package Installer\"))\n")
	write("\tfmt.Printf(\"\\n%s\\n\", t.Styled(t.Bold, \"Usage:\"))\n")
	write("\tfmt.Printf(\"  pi %s\\n\", t.Styled(t.Yellow, \"[flags] <command>\"))\n")
	write("\tfmt.Printf(\"\\n%s\\n\", t.Styled(t.Bold, \"Global Flags:\"))\n")
	write("\tfmt.Printf(\"  %-12s %s\\n\", t.Styled(t.Cyan, \"--help, -h\"), t.Styled(t.Dim, \"Show help [command | topic]\"))\n")
	write("\tfor _, f := range cliGlobalFlags {\n")
	write("\t\tshort := \"\"\n")
	write("\t\tif f.Short != \"\" {\n")
	write("\t\t\tshort = \", -\" + f.Short\n")
	write("\t\t}\n")
	write("\t\tfmt.Printf(\"  %-12s %s\\n\", t.Styled(t.Cyan, \"--\"+f.Name+short), t.Styled(t.Dim, f.Desc))\n")
	write("\t}\n")
	write("\tcategories := []struct {\n")
	write("\t\tname string\n")
	write("\t\ticon string\n")
	write("\t\tcmds []string\n")
	write("\t}{\n")
	write("\t\t{\"PACKAGE\", t.IconPkg, []string{\"pkg\"}},\n")
	write("\t\t{\"CAVE\", t.IconCave, []string{\"cave\"}},\n")
	write("\t\t{\"DISK\", t.IconDisk, []string{\"disk\"}},\n")
	write("\t\t{\"REPO\", t.IconWorld, []string{\"repo\"}},\n")
	write("\t}\n")
	write("\tshown := make(map[string]bool)\n")
	write("\tfmt.Println()\n")
	write("\tfor _, cat := range categories {\n")
	write("\t\tfor _, name := range cat.cmds {\n")
	write("\t\t\tfor _, c := range cliCommands {\n")
	write("\t\t\t\tif c.Name == name {\n")
	write("\t\t\t\t\tprintCommandTree(t, c, \"\", true, cat.icon)\n")
	write("\t\t\t\t\tfmt.Println()\n")
	write("\t\t\t\t\tshown[c.Name] = true\n")
	write("\t\t\t\t}\n")
	write("\t\t\t}\n")
	write("\t\t}\n")
	write("\t}\n")
	write("\tvar misc []*commandDef\n")
	write("\tfor _, c := range cliCommands {\n")
	write("\t\tif !shown[c.Name] && c.Name != \"help\" {\n")
	write("\t\t\tmisc = append(misc, c)\n")
	write("\t\t}\n")
	write("\t}\n")
	write("\tif len(misc) > 0 {\n")
	write("\t\tfmt.Printf(\"%s %s\\n\", t.Bullet, t.Styled(t.Bold, \"MISC\"))\n")
	write("\t\tfor i, c := range misc {\n")
	write("\t\t\tprintCommandTree(t, c, \"\", i == len(misc)-1, \"\")\n")
	write("\t\t}\n")
	write("\t\tfmt.Println()\n")
	write("\t}\n")
	write("\tfmt.Printf(\"%s %s\\n\", t.IconHelp, t.Styled(t.Bold, \"Topics:\"))\n")
	write("\tfor _, topic := range cliTopics {\n")
	write("\t\tname := t.Styled(t.Cyan, topic.Name)\n")
	write("\t\tpadding := getPadding(t, topic.Name, 20)\n")
	write("\t\tfmt.Printf(\"  %s %s %s\\n\", name, padding, t.Styled(t.Dim, topic.Desc))\n")
	write("\t}\n")
	write("\tfmt.Printf(\"\\nType '%s' for more details.\\n\", t.Styled(t.Yellow, \"pi help <command>\"))\n")
	write("}\n\n")

	write("func printCommandHelp(t *Theme, c *commandDef) {\n")
	write("\tfmt.Printf(\"\\n%s %s\\n\", t.Styled(t.Bold, \"Command:\"), t.Styled(t.Cyan, getCmdPath(c)))\n")
	write("\tfmt.Printf(\"%s %s\\n\", t.Styled(t.Bold, \"Description:\"), t.Styled(t.Dim, c.Desc))\n")
	write("\tfmt.Println()\n")
	write("\tif len(c.Subs) > 0 {\n")
	write("\t\tfmt.Printf(\"%s\\n\", t.Styled(t.Bold, \"Subcommands:\"))\n")
	write("\t\tfor i, s := range c.Subs {\n")
	write("\t\t\tprefix := t.BoxTree\n")
	write("\t\t\tif i == len(c.Subs)-1 {\n")
	write("\t\t\t\tprefix = t.BoxLast\n")
	write("\t\t\t}\n")
	write("\t\t\tfmt.Printf(\"  %s %-12s %s\\n\", prefix, t.Styled(t.Cyan, s.Name), t.Styled(t.Dim, s.Desc))\n")
	write("\t\t}\n")
	write("\t\tfmt.Println()\n")
	write("\t}\n")
	write("\tif len(c.Args) > 0 {\n")
	write("\t\tfmt.Printf(\"%s\\n\", t.Styled(t.Bold, \"Arguments:\"))\n")
	write("\t\tfor _, a := range c.Args {\n")
	write("\t\t\tfmt.Printf(\"  %-15s %s\\n\", t.Styled(t.Yellow, \"<\"+a.Name+\">\"), t.Styled(t.Dim, a.Desc))\n")
	write("\t\t}\n")
	write("\t\tfmt.Println()\n")
	write("\t}\n")
	write("\tif len(c.Flags) > 0 {\n")
	write("\t\tfmt.Printf(\"%s\\n\", t.Styled(t.Bold, \"Flags:\"))\n")
	write("\t\tfor _, f := range c.Flags {\n")
	write("\t\t\tshort := \"\"\n")
	write("\t\t\tif f.Short != \"\" {\n")
	write("\t\t\t\tshort = \", -\" + f.Short\n")
	write("\t\t\t}\n")
	write("\t\t\tfmt.Printf(\"  %-15s %s\\n\", t.Styled(t.Cyan, \"--\"+f.Name+short), t.Styled(t.Dim, f.Desc))\n")
	write("\t\t}\n")
	write("\t\tfmt.Println()\n")
	write("\t}\n")
	write("\tif len(c.Examples) > 0 {\n")
	write("\t\tfmt.Printf(\"%s\\n\", t.Styled(t.Bold, \"Examples:\"))\n")
	write("\t\tfor _, ex := range c.Examples {\n")
	write("\t\t\tfmt.Printf(\"  %s %s\\n\", t.Styled(t.Green, \"$\"), ex)\n")
	write("\t\t}\n")
	write("\t\tfmt.Println()\n")
	write("\t}\n")
	write("}\n\n")

	write("func printTopicHelp(t *Theme, topic *topicDef) {\n")
	write("\tfmt.Printf(\"\\n%s %s\\n\", t.Styled(t.Bold, \"Topic:\"), t.Styled(t.Cyan, topic.Name))\n")
	write("\tfmt.Printf(\"%s %s\\n\", t.Styled(t.Bold, \"Description:\"), t.Styled(t.Dim, topic.Desc))\n")
	write("\tfmt.Println()\n")
	write("\tfmt.Printf(\"%s\\n\\n\", topic.Text)\n")
	write("}\n\n")

	write("func getPadding(t *Theme, name string, target int) string {\n")
	write("\tdots := target - len(name)\n")
	write("\tif dots < 2 {\n")
	write("\t\tdots = 2\n")
	write("\t}\n")
	write("\treturn t.Styled(t.Dim, strings.Repeat(\".\", dots))\n")
	write("}\n\n")

	write("func printCommandTree(t *Theme, c *commandDef, indent string, isLast bool, icon string) {\n")
	write("\tprefix := t.BoxTree\n")
	write("\tif isLast {\n")
	write("\t\tprefix = t.BoxLast\n")
	write("\t}\n")
	write("\tnamePart := indent + prefix + \" \"\n")
	write("\tif icon != \"\" {\n")
	write("\t\tnamePart += icon + \" \"\n")
	write("\t}\n")
	write("\tnamePart += t.Styled(t.Cyan, c.Name)\n")
	write("\tvisualLen := len(indent) + 4\n")
	write("\tif icon != \"\" {\n")
	write("\t\tvisualLen += 3\n")
	write("\t}\n")
	write("\tvisualLen += len(c.Name)\n")
	write("\tpadding := getPadding(t, strings.Repeat(\" \", visualLen), 30)\n")
	write("\tline := fmt.Sprintf(\"%s %s %s\", namePart, padding, t.Styled(t.Dim, c.Desc))\n")
	write("\tfmt.Println(line)\n")
	write("\tnewIndent := indent\n")
	write("\tif isLast {\n")
	write("\t\tnewIndent += \"    \"\n")
	write("\t} else {\n")
	write("\t\tnewIndent += t.BoxItem + \" \"\n")
	write("\t}\n")
	write("\tfor i, s := range c.Subs {\n")
	write("\t\tprintCommandTree(t, s, newIndent, i == len(c.Subs)-1, \"\")\n")
	write("\t}\n")
	write("}\n\n")

	write("func getCmdPath(c *commandDef) string {\n")
	write("\tif c.Parent == nil {\n")
	write("\t\treturn c.Name\n")
	write("\t}\n")
	write("\treturn getCmdPath(c.Parent) + \"/\" + c.Name\n")
	write("}\n\n")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, err
	}
	return formatted, nil
}

func goTypeForFlag(t string) string {
	switch t {
	case "bool":
		return "bool"
	case "string":
		return "string"
	default:
		return "string"
	}
}

func goTypeForArg(t string) string {
	return "string"
}

func collectLeafCommands(cmds []*defCommand) []*defCommand {
	var out []*defCommand
	walkCommands(cmds, func(c *defCommand) {
		if len(c.Subs) == 0 {
			out = append(out, c)
		}
	})
	return out
}

func walkCommands(cmds []*defCommand, fn func(*defCommand)) {
	for _, c := range cmds {
		fn(c)
		if len(c.Subs) > 0 {
			walkCommands(c.Subs, fn)
		}
	}
}

func cmdPath(c *defCommand) string {
	if c.Parent == nil {
		return c.Name
	}
	return cmdPath(c.Parent) + "/" + c.Name
}

func goNameForPath(path string) string {
	parts := strings.Split(path, "/")
	var out string
	for _, p := range parts {
		out += goFieldName(p)
	}
	return out
}

func goFieldName(name string) string {
	parts := splitIdent(name)
	var out string
	for _, p := range parts {
		if p == "" {
			continue
		}
		out += strings.ToUpper(p[:1]) + p[1:]
	}
	if out == "" {
		return "X"
	}
	if out[0] >= '0' && out[0] <= '9' {
		return "X" + out
	}
	return out
}

func lowerFirst(s string) string {
	if s == "" {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func splitIdent(s string) []string {
	return strings.FieldsFunc(s, func(r rune) bool {
		switch r {
		case '-', '_', '.', ':':
			return true
		default:
			return false
		}
	})
}

func isValidIdent(s string) bool {
	if s == "" {
		return false
	}
	for i, r := range s {
		if i == 0 {
			if !(r == '_' || (r >= 'A' && r <= 'Z') || (r >= 'a' && r <= 'z')) {
				return false
			}
			continue
		}
		if !(r == '_' || (r >= 'A' && r <= 'Z') || (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9')) {
			return false
		}
	}
	return true
}

// Parser

type tokenKind int

const (
	tokError tokenKind = iota
	tokEOF
	tokIdentifier
	tokString
)

type token struct {
	kind  tokenKind
	value string
	line  int
}

type lexer struct {
	input string
	pos   int
	line  int
}

func newLexer(input string) *lexer {
	return &lexer{
		input: input,
		line:  1,
	}
}

func (l *lexer) nextToken() token {
	l.skipWhitespaceAndComments()

	if l.pos >= len(l.input) {
		return token{kind: tokEOF, line: l.line}
	}

	b := l.input[l.pos]

	if b == '"' {
		return l.readString()
	}

	if isAlpha(b) || b == '/' || b == '.' {
		return l.readIdentifier()
	}

	l.pos++
	return token{kind: tokError, value: fmt.Sprintf("unexpected character: %c", b), line: l.line}
}

func (l *lexer) skipWhitespaceAndComments() {
	for l.pos < len(l.input) {
		b := l.input[l.pos]
		switch b {
		case '\n':
			l.line++
			l.pos++
		case ' ', '\t', '\r', '\f', '\v':
			l.pos++
		case '#':
			l.skipComment()
		default:
			return
		}
	}
}

func (l *lexer) skipComment() {
	for l.pos < len(l.input) && l.input[l.pos] != '\n' {
		l.pos++
	}
}

func (l *lexer) readIdentifier() token {
	start := l.pos
	for l.pos < len(l.input) {
		b := l.input[l.pos]
		if isAlphaNumeric(b) || b == '_' || b == '-' || b == '/' || b == '.' {
			l.pos++
		} else {
			break
		}
	}
	return token{kind: tokIdentifier, value: l.input[start:l.pos], line: l.line}
}

func (l *lexer) readString() token {
	l.pos++
	if l.pos+1 < len(l.input) && l.input[l.pos] == '"' && l.input[l.pos+1] == '"' {
		l.pos += 2
		return l.readMultilineString()
	}
	start := l.pos
	for l.pos < len(l.input) && l.input[l.pos] != '"' {
		if l.input[l.pos] == '\n' {
			l.line++
		}
		l.pos++
	}
	if l.pos >= len(l.input) {
		return token{kind: tokError, value: "unterminated string", line: l.line}
	}
	val := l.input[start:l.pos]
	l.pos++
	return token{kind: tokString, value: val, line: l.line}
}

func (l *lexer) readMultilineString() token {
	start := l.pos
	for l.pos+2 < len(l.input) {
		if l.input[l.pos] == '"' && l.input[l.pos+1] == '"' && l.input[l.pos+2] == '"' {
			val := l.input[start:l.pos]
			l.pos += 3
			return token{kind: tokString, value: l.processMultiline(val), line: l.line}
		}
		if l.input[l.pos] == '\n' {
			l.line++
		}
		l.pos++
	}
	return token{kind: tokError, value: "unterminated multiline string", line: l.line}
}

func (l *lexer) processMultiline(s string) string {
	var sb strings.Builder
	lines := strings.Split(s, "\n")
	startIdx := 0
	for startIdx < len(lines) && strings.TrimSpace(lines[startIdx]) == "" {
		startIdx++
	}
	endIdx := len(lines) - 1
	for endIdx >= startIdx && strings.TrimSpace(lines[endIdx]) == "" {
		endIdx--
	}
	if startIdx > endIdx {
		return ""
	}
	for i := startIdx; i <= endIdx; i++ {
		line := lines[i]
		trimmed := strings.TrimLeft(line, " \t")
		if trimmed != "" {
			sb.WriteByte(' ')
			sb.WriteString(trimmed)
		}
		if i < endIdx {
			sb.WriteByte('\n')
		}
	}
	return sb.String()
}

func isAlpha(b byte) bool {
	return (b >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z')
}

func isAlphaNumeric(b byte) bool {
	return isAlpha(b) || (b >= '0' && b <= '9')
}

type parser struct {
	lex       *lexer
	tok       token
	def       *defFile
	lastCmd   *defCommand
	lastTopic *defTopic
	pathBuf   [8]string
}

func parseDef(dsl string) (*defFile, error) {
	p := &parser{lex: newLexer(dsl), def: &defFile{}}
	p.next()
	if err := p.parse(); err != nil {
		return nil, err
	}
	return p.def, nil
}

func (p *parser) next() {
	p.tok = p.lex.nextToken()
}

func (p *parser) parse() error {
	for p.tok.kind != tokEOF {
		if p.tok.kind == tokError {
			return fmt.Errorf("line %d: %s", p.tok.line, p.tok.value)
		}
		if err := p.parseStatement(); err != nil {
			return err
		}
	}
	return nil
}

func (p *parser) parseStatement() error {
	if p.tok.kind != tokIdentifier {
		return fmt.Errorf("line %d: expected keyword, got %v", p.tok.line, p.tok.value)
	}
	keyword := p.tok.value
	switch keyword {
	case "global":
		p.lastCmd = nil
		p.lastTopic = nil
		p.next()
		return nil
	case "cmd":
		return p.parseCommand()
	case "flag":
		return p.parseFlag()
	case "arg":
		return p.parseArg()
	case "example":
		return p.parseExample()
	case "topic":
		return p.parseTopic()
	case "text":
		return p.parseText()
	case "safe":
		if p.lastCmd == nil {
			return fmt.Errorf("line %d: 'safe' must follow a 'cmd'", p.tok.line)
		}
		p.lastCmd.SafeInCave = true
		p.next()
		return nil
	default:
		return fmt.Errorf("line %d: unknown keyword %q", p.tok.line, keyword)
	}
}

func (p *parser) parseFlag() error {
	p.next()
	if p.tok.kind != tokIdentifier {
		return fmt.Errorf("line %d: expected flag name", p.tok.line)
	}
	name := p.tok.value
	p.next()
	if p.tok.kind != tokIdentifier {
		return fmt.Errorf("line %d: expected flag type", p.tok.line)
	}
	fType := p.tok.value
	p.next()
	if p.tok.kind != tokString {
		return fmt.Errorf("line %d: expected flag description", p.tok.line)
	}
	desc := p.tok.value
	p.next()
	f := &defFlag{Name: name, Type: fType, Desc: desc}
	if p.tok.kind == tokIdentifier {
		f.Short = p.tok.value
		p.next()
	}
	if p.lastCmd == nil {
		p.def.GlobalFlags = append(p.def.GlobalFlags, f)
	} else {
		p.lastCmd.Flags = append(p.lastCmd.Flags, f)
	}
	return nil
}

func (p *parser) parseCommand() error {
	p.next()
	path := p.pathBuf[:0]
	for p.tok.kind == tokIdentifier {
		path = append(path, p.tok.value)
		p.next()
	}
	if len(path) == 0 {
		return fmt.Errorf("line %d: expected command name or path", p.tok.line)
	}
	desc := ""
	if p.tok.kind == tokString {
		desc = p.tok.value
		p.next()
	}
	var parent *defCommand
	var current *defCommand
	for i, name := range path {
		var list *[]*defCommand
		if parent == nil {
			list = &p.def.Commands
		} else {
			list = &parent.Subs
		}
		found := false
		for _, c := range *list {
			if c.Name == name {
				current = c
				found = true
				break
			}
		}
		if !found {
			current = &defCommand{Name: name, Parent: parent}
			*list = append(*list, current)
		}
		if i == len(path)-1 && desc != "" {
			current.Desc = desc
		}
		parent = current
	}
	p.lastCmd = current
	return nil
}

func (p *parser) parseArg() error {
	if p.lastCmd == nil {
		return fmt.Errorf("line %d: 'arg' must follow a 'cmd'", p.tok.line)
	}
	p.next()
	if p.tok.kind != tokIdentifier {
		return fmt.Errorf("line %d: expected arg name", p.tok.line)
	}
	name := p.tok.value
	p.next()
	if p.tok.kind != tokIdentifier {
		return fmt.Errorf("line %d: expected arg type", p.tok.line)
	}
	aType := p.tok.value
	p.next()
	if p.tok.kind != tokString {
		return fmt.Errorf("line %d: expected arg description", p.tok.line)
	}
	desc := p.tok.value
	p.next()
	p.lastCmd.Args = append(p.lastCmd.Args, &defArg{Name: name, Type: aType, Desc: desc})
	return nil
}

func (p *parser) parseExample() error {
	if p.lastCmd == nil {
		return fmt.Errorf("line %d: 'example' must follow a 'cmd'", p.tok.line)
	}
	p.next()
	if p.tok.kind != tokString {
		return fmt.Errorf("line %d: expected example string", p.tok.line)
	}
	p.lastCmd.Examples = append(p.lastCmd.Examples, p.tok.value)
	p.next()
	return nil
}

func (p *parser) parseTopic() error {
	p.next()
	if p.tok.kind != tokIdentifier {
		return fmt.Errorf("line %d: expected topic name", p.tok.line)
	}
	name := p.tok.value
	p.next()
	if p.tok.kind != tokString {
		return fmt.Errorf("line %d: expected topic description", p.tok.line)
	}
	desc := p.tok.value
	p.next()
	t := &defTopic{Name: name, Desc: desc}
	p.def.Topics = append(p.def.Topics, t)
	p.lastTopic = t
	return nil
}

func (p *parser) parseText() error {
	if p.lastTopic == nil {
		return fmt.Errorf("line %d: 'text' must follow a 'topic'", p.tok.line)
	}
	p.next()
	if p.tok.kind != tokString {
		return fmt.Errorf("line %d: expected text string", p.tok.line)
	}
	p.lastTopic.Text = p.tok.value
	p.next()
	return nil
}
