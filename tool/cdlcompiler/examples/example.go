// Code generated by cligen; DO NOT EDIT.

package main

import (
	"fmt"
)

type flagDef struct {
	Name  string
	Short string
	Type  string
	Desc  string
}

type argDef struct {
	Name string
	Type string
	Desc string
}

type commandDef struct {
	Name     string
	Desc     string
	Args     []*argDef
	Flags    []*flagDef
	Subs     []*commandDef
	Parent   *commandDef
	Examples []string
}

type topicDef struct {
	Name string
	Desc string
	Text string
}

type globalFlags struct {
	Verbose bool
}

type projectInitParams struct {
	globalFlags
	Path string
}

type userAddParams struct {
	globalFlags
	Name string
}

type Handlers interface {
	ProjectInit(params *projectInitParams) Action
	UserAdd(params *userAddParams) Action
}

var cliGlobalFlags = []*flagDef{
	{Name: "verbose", Short: "v", Type: "bool", Desc: "Enable verbose output"},
}

var cliTopics = []*topicDef{}

var cliCommands = buildCommands()
var cliAppName = "example"
var cliTagline = "Minimal CLI sample"

func buildCommands() []*commandDef {
	cmdUser := &commandDef{Name: "user", Desc: "Manage users"}
	cmdUserAdd := &commandDef{Name: "add", Desc: "Add a user", Parent: cmdUser, Args: []*argDef{{Name: "name", Type: "string", Desc: "User name"}}, Examples: []string{"app user add alice"}}
	cmdProject := &commandDef{Name: "project", Desc: "Manage projects"}
	cmdProjectInit := &commandDef{Name: "init", Desc: "Initialize a project", Parent: cmdProject, Args: []*argDef{{Name: "path", Type: "string", Desc: "Project path"}}, Examples: []string{"app project init ./demo"}}
	cmdHelp := &commandDef{Name: "help", Desc: "Show help information"}
	cmdUser.Subs = []*commandDef{cmdUserAdd}
	cmdProject.Subs = []*commandDef{cmdProjectInit}

	return []*commandDef{cmdUser, cmdProject, cmdHelp}
}

type invocation struct {
	Command *commandDef
	Args    map[string]string
	Flags   map[string]any
}

func Parse(h Handlers, args []string) (Action, error) {
	if h == nil {
		return nil, fmt.Errorf("handlers is nil")
	}
	var gf globalFlags
	var remaining []string
	help := false
	for i := 0; i < len(args); i++ {
		arg := args[i]
		if arg == "--help" || arg == "-h" {
			help = true
			continue
		}
		found := false
		for _, f := range cliGlobalFlags {
			if arg == "--"+f.Name || (f.Short != "" && arg == "-"+f.Short) {
				found = true
				if f.Type == "bool" {
					applyGlobalFlag(&gf, f.Name, true)
				} else if f.Type == "string" && i+1 < len(args) {
					applyGlobalFlag(&gf, f.Name, args[i+1])
					i++
				}
			}
		}
		if !found {
			remaining = append(remaining, arg)
		}
	}
	if help || len(remaining) == 0 {
		return helpAction(remaining), nil
	}
	if remaining[0] == "help" {
		return helpAction(remaining[1:]), nil
	}
	inv := &invocation{Args: make(map[string]string), Flags: make(map[string]any)}
	finalInv, err := resolve(inv, cliCommands, remaining)
	if err != nil {
		return nil, err
	}
	if finalInv == nil || finalInv.Command == nil {
		return nil, fmt.Errorf("no command resolved")
	}
	path := getCmdPath(finalInv.Command)
	switch path {
	case "project/init":
		params := &projectInitParams{}
		params.Path = finalInv.Args["path"]
		params.globalFlags = gf
		action := h.ProjectInit(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "user/add":
		params := &userAddParams{}
		params.Name = finalInv.Args["name"]
		params.globalFlags = gf
		action := h.UserAdd(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
	case "help":
		return helpAction(nil), nil
	default:
		return nil, fmt.Errorf("no handler for command: %s", path)
	}
}

func helpAction(args []string) Action {
	return func() (*ExecutionResult, error) {
		printHelp(args...)
		return &ExecutionResult{ExitCode: 0}, nil
	}
}

func applyGlobalFlag(g *globalFlags, name string, val any) {
	switch name {
	case "verbose":
		if b, ok := val.(bool); ok {
			g.Verbose = b
		}
	}
}
