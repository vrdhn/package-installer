// Code generated by cligen; DO NOT EDIT.

package cli

import (
	"fmt"
	"os"
	"strings"
)

func BoolFlag(flags map[string]any, name string) bool {
	if v, ok := flags[name]; ok {
		if b, ok := v.(bool); ok {
			return b
		}
	}
	return false
}

func StringFlag(flags map[string]any, name string) string {
	if v, ok := flags[name]; ok {
		if s, ok := v.(string); ok {
			return s
		}
	}
	return ""
}

func ProcessGlobalFlags(args []string, gf *GlobalFlags) []string {
	var remaining []string
	for i := 0; i < len(args); i++ {
		arg := args[i]
		found := false
		for _, f := range CliGlobalFlags {
			if arg == "--"+f.Name || (f.Short != "" && arg == "-"+f.Short) {
				found = true
				if f.Type == "bool" {
					ApplyGlobalFlag(gf, f.Name, true)
				} else if f.Type == "string" && i+1 < len(args) {
					ApplyGlobalFlag(gf, f.Name, args[i+1])
					i++
				}
				break
			}
		}
		if !found {
			remaining = append(remaining, arg)
		}
	}
	return remaining
}

func Resolve(cmds []CommandDef, args []string) (*CommandDef, []string, error) {
	if len(args) == 0 {
		return nil, nil, fmt.Errorf("no command provided")
	}

	// Try leading path/to/cmd
	if strings.Contains(args[0], "/") {
		path := args[0]
		target, err := findCommandByPath(CliCommands, path)
		if err == nil {
			return target, args[1:], nil
		}
		return nil, nil, fmt.Errorf("unknown command path: %s", path)
	}

	// Try leading words as contiguous command path
	target, rem, err := resolvePath(cmds, args)
	if err == nil {
		return target, rem, nil
	}

	// If not found at start, search tree for unique match of the first word
	// (allowing command to be optional)
	target, err = findUniqueCommand(CliCommands, args[0])
	if err == nil {
		return target, args[1:], nil
	}

	return nil, nil, err
}

func findCommandByPath(cmds []CommandDef, path string) (*CommandDef, error) {
	parts := strings.Split(path, "/")
	curr := cmds
	var found *CommandDef
	for _, p := range parts {
		if p == "" {
			continue
		}
		var matches []*CommandDef
		for i := range curr {
			if curr[i].Name == p || strings.HasPrefix(curr[i].Name, p) {
				matches = append(matches, &curr[i])
			}
		}
		if len(matches) == 0 {
			return nil, fmt.Errorf("not found")
		}
		if len(matches) > 1 {
			return nil, fmt.Errorf("ambiguous")
		}
		found = matches[0]
		curr = found.Subs
	}
	return found, nil
}

func resolvePath(cmds []CommandDef, args []string) (*CommandDef, []string, error) {
	if len(args) == 0 {
		return nil, nil, fmt.Errorf("empty args")
	}
	word := args[0]
	if strings.HasPrefix(word, "-") {
		return nil, nil, fmt.Errorf("expected command, got flag: %s", word)
	}

	var matches []int
	for i, c := range cmds {
		if c.Name == word {
			matches = []int{i}
			break
		}
		if strings.HasPrefix(c.Name, word) {
			matches = append(matches, i)
		}
	}

	if len(matches) > 1 {
		var names []string
		for _, idx := range matches {
			names = append(names, cmds[idx].Name)
		}
		return nil, nil, fmt.Errorf("ambiguous command: %s (candidates: %s)", word, strings.Join(names, ", "))
	}

	if len(matches) == 1 {
		cmd := &cmds[matches[0]]
		if len(cmd.Subs) > 0 && len(args) > 1 && !strings.HasPrefix(args[1], "-") {
			sub, rem, err := resolvePath(cmd.Subs, args[1:])
			if err == nil {
				return sub, rem, nil
			}
		}
		return cmd, args[1:], nil
	}

	return nil, nil, fmt.Errorf("unknown command: %s", word)
}

func findUniqueCommand(cmds []CommandDef, name string) (*CommandDef, error) {
	var matches []*CommandDef
	var walk func(cs []CommandDef)
	walk = func(cs []CommandDef) {
		for i := range cs {
			if cs[i].Name == name || strings.HasPrefix(cs[i].Name, name) {
				matches = append(matches, &cs[i])
			}
			walk(cs[i].Subs)
		}
	}
	walk(cmds)

	if len(matches) == 0 {
		return nil, fmt.Errorf("unknown command: %s", name)
	}
	if len(matches) > 1 {
		var paths []string
		for _, m := range matches {
			paths = append(paths, m.FullCommand)
		}
		return nil, fmt.Errorf("ambiguous command: %s (matches: %s)", name, strings.Join(paths, ", "))
	}
	return matches[0], nil
}

func ParseParams(inv *Invocation, cmd *CommandDef, args []string) error {
	argIdx := 0
	for i := 0; i < len(args); i++ {
		arg := args[i]
		if strings.HasPrefix(arg, "-") {
			found := false
			for _, f := range cmd.Flags {
				if arg == "--"+f.Name || (f.Short != "" && arg == "-"+f.Short) {
					if f.Type == "bool" {
						inv.Flags[f.Name] = true
						found = true
					} else if f.Type == "string" && i+1 < len(args) {
						inv.Flags[f.Name] = args[i+1]
						i++
						found = true
					}
					break
				}
			}
			if !found {
				if argIdx < len(cmd.Args) {
					inv.Args[cmd.Args[argIdx].Name] = arg
					argIdx++
				} else {
					return fmt.Errorf("unknown flag or extra argument: %s", arg)
				}
			}
		} else {
			if argIdx < len(cmd.Args) {
				inv.Args[cmd.Args[argIdx].Name] = arg
				argIdx++
			} else {
				return fmt.Errorf("extra argument: %s", arg)
			}
		}
	}
	if argIdx < len(cmd.Args) {
		return fmt.Errorf("argument %s is missing", cmd.Args[argIdx].Name)
	}
	return nil
}

type HelpData struct {
	Topic       *TopicDef
	Command     *CommandDef
	Root        *RootHelpData
	CommandPath string
}

type RootHelpData struct {
	GlobalFlags []FlagDef
	Topics      []TopicDef
	Commands    []CommandDef
	Name        string
	Tagline     string
}

func PrintHelp(args []string) {
	if len(args) > 0 {
		subject := args[0]
		for _, topic := range CliTopics {
			if topic.Name == subject || strings.HasPrefix(topic.Name, subject) {
				RenderHelp(HelpData{Topic: &topic})
				return
			}
		}

		cmd, _, err := Resolve(CliCommands, args)
		if err == nil {
			RenderHelp(HelpData{Command: cmd, CommandPath: GetCmdPath(cmd)})
			return
		}
	}

	var cmds []CommandDef
	for i := range CliCommands {
		c := CliCommands[i]
		if c.Name == "help" {
			continue
		}
		cmds = append(cmds, c)
	}

	RenderHelp(HelpData{Root: &RootHelpData{
		GlobalFlags: CliGlobalFlags,
		Topics:      CliTopics,
		Commands:    cmds,
		Name:        CliAppName,
		Tagline:     CliTagline,
	}})
}

func RenderHelp(data HelpData) {
	var b strings.Builder
	switch {
	case data.Topic != nil:
		fmt.Fprintf(&b, "Topic: %s\nDescription: %s\n\n%s\n", data.Topic.Name, data.Topic.Desc, data.Topic.Text)
	case data.Command != nil:
		fmt.Fprintf(&b, "Command: %s\nDescription: %s\n\n", data.CommandPath, data.Command.Desc)
		if len(data.Command.Subs) > 0 {
			b.WriteString("Subcommands:\n")
			for _, sub := range data.Command.Subs {
				fmt.Fprintf(&b, "  %s    %s\n", sub.Name, sub.Desc)
			}
			b.WriteString("\n")
		}
		if len(data.Command.Args) > 0 {
			b.WriteString("Arguments:\n")
			for _, arg := range data.Command.Args {
				fmt.Fprintf(&b, "  <%s>    %s\n", arg.Name, arg.Desc)
			}
			b.WriteString("\n")
		}
		if len(data.Command.Flags) > 0 {
			b.WriteString("Flags:\n")
			for _, flag := range data.Command.Flags {
				fmt.Fprintf(&b, "  --%s", flag.Name)
				if flag.Short != "" {
					fmt.Fprintf(&b, ", -%s", flag.Short)
				}
				fmt.Fprintf(&b, "    %s\n", flag.Desc)
			}
			b.WriteString("\n")
		}
		if len(data.Command.Examples) > 0 {
			b.WriteString("Examples:\n")
			for _, ex := range data.Command.Examples {
				fmt.Fprintf(&b, "  $ %s\n", ex)
			}
		}
	default:
		WriteRootHelp(&b, data.Root)
	}
	if _, err := os.Stdout.WriteString(b.String()); err != nil {
		fmt.Fprintf(os.Stderr, "help render error: %v\n", err)
	}
}

func WriteRootHelp(b *strings.Builder, root *RootHelpData) {
	if root == nil {
		return
	}
	name := "<program>"
	if root.Name != "" {
		name = root.Name
		fmt.Fprintf(b, "%s : %s\n\n", root.Name, root.Tagline)
	}
	fmt.Fprintf(b, "Usage:\n  %s [flags] <command>\n\n", name)
	b.WriteString("Global Flags:\n")
	for _, flag := range root.GlobalFlags {
		fmt.Fprintf(b, "  --%s", flag.Name)
		if flag.Short != "" {
			fmt.Fprintf(b, ", -%s", flag.Short)
		}
		fmt.Fprintf(b, "    %s\n", flag.Desc)
	}
	b.WriteString("\nCommands:\n")
	for _, cmd := range root.Commands {
		fmt.Fprintf(b, "  %s    %s\n", cmd.Name, cmd.Desc)
		if len(cmd.Subs) > 0 {
			for _, sub := range cmd.Subs {
				fmt.Fprintf(b, "      %s    %s\n", sub.Name, sub.Desc)
			}
		}
	}
	if len(root.Topics) > 0 {
		b.WriteString("\nTopics:\n")
		for _, topic := range root.Topics {
			fmt.Fprintf(b, "  %s    %s\n", topic.Name, topic.Desc)
		}
	}
	fmt.Fprintf(b, "\nType '%s help <command>' for more details.\n", name)
}

func GetCmdPath(c *CommandDef) string {
	return c.FullCommand
}
