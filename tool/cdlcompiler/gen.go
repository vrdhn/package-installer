package main

import (
	"bytes"
	"go/format"
	"sort"
	"text/template"
)

type genData struct {
	Pkg          string
	GlobalFlags  []*flag
	Topics       []*topic
	Commands     []*command
	AllCommands  []*command
	Leafs        []*command
	ParamDefs    []param
	CmdVarName   map[*command]string
	HelpTemplate string
}

func generate(cdl *cdlTop, pkgName string) ([]byte, error) {
	params, err := collectParams(cdl)
	if err != nil {
		return nil, err
	}

	leafs := collectLeafCommands(cdl.Commands)
	sort.Slice(leafs, func(i, j int) bool { return cmdPath(leafs[i]) < cmdPath(leafs[j]) })

	cmdVars := map[*command]string{}
	var all []*command
	walkCommands(cdl.Commands, func(c *command) {
		all = append(all, c)
	})

	helpCmd := &command{
		Name:   "help",
		Desc:   "Show help information",
		Params: map[string]value{"safe": {Kind: "bool", Bool: true}}}
	topCommands := append(append([]*command{}, cdl.Commands...), helpCmd)
	all = append(all, helpCmd)

	for _, c := range all {
		cmdVars[c] = "cmd" + goNameForPath(cmdPath(c))
	}

	data := genData{
		Pkg:          pkgName,
		GlobalFlags:  cdl.GlobalFlags,
		Topics:       cdl.Topics,
		Commands:     topCommands,
		AllCommands:  all,
		Leafs:        leafs,
		ParamDefs:    params,
		CmdVarName:   cmdVars,
		HelpTemplate: helpTemplateContent,
	}

	funcs := template.FuncMap{
		"goFieldName":    goFieldName,
		"goTypeForParam": goTypeForParam,
		"goTypeForFlag":  goTypeForFlag,
		"goTypeForArg":   goTypeForArg,
		"lowerFirst":     lowerFirst,
		"goNameForPath":  goNameForPath,
		"cmdPath":        cmdPath,
		"cmdVar": func(c *command) string {
			return cmdVars[c]
		},
		"paramLiteral": func(cmd *command, name string, kind string) string {
			val, _ := resolveParam(cdl, cmd, name)
			return emitParamLiteral(val, kind)
		},
	}

	tmpl, err := template.New("cli").Funcs(funcs).Parse(cliTemplate)
	if err != nil {
		return nil, err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, err
	}
	return formatted, nil
}

const helpTemplateContent = `{{ if .Topic }}
Topic: {{ .Topic.Name }}
Description: {{ .Topic.Desc }}

{{ .Topic.Text }}
{{ else if .Command }}
Command: {{ .CommandPath }}
Description: {{ .Command.Desc }}

{{ if .Command.Subs }}
Subcommands:
{{ range .Command.Subs }}
  {{ .Name }}    {{ .Desc }}
{{ end }}
{{ end }}

{{ if .Command.Args }}
Arguments:
{{ range .Command.Args }}
  <{{ .Name }}>    {{ .Desc }}
{{ end }}
{{ end }}

{{ if .Command.Flags }}
Flags:
{{ range .Command.Flags }}
  --{{ .Name }}{{ if .Short }}, -{{ .Short }}{{ end }}    {{ .Desc }}
{{ end }}
{{ end }}

{{ if .Command.Examples }}
Examples:
{{ range .Command.Examples }}
  $ {{ . }}
{{ end }}
{{ end }}

{{ else }}
Command Line Interface

Usage:
  <program> [flags] <command>

Global Flags:
  --help, -h    Show help [command | topic]
{{ range .Root.GlobalFlags }}
  --{{ .Name }}{{ if .Short }}, -{{ .Short }}{{ end }}    {{ .Desc }}
{{ end }}

Commands:
{{ range .Root.Categories }}
  {{ .Name }}:
{{ range .Cmds }}
    {{ .Cmd.Name }}    {{ .Cmd.Desc }}
{{ end }}
{{ end }}

Topics:
{{ range .Root.Topics }}
  {{ .Name }}    {{ .Desc }}
{{ end }}

Type '<program> help <command>' for more details.
{{ end }}
`

const cliTemplate = `// Code generated by cligen; DO NOT EDIT.

package {{.Pkg}}

import (
	"fmt"
	"strings"
	"text/template"
	"os"
)

type flagDef struct {
	Name  string
	Short string
	Type  string
	Desc  string
}

type argDef struct {
	Name string
	Type string
	Desc string
}

type commandDef struct {
	Name string
	Desc string
{{- range .ParamDefs }}
	{{ goFieldName .Name }} {{ goTypeForParam .Kind }}
{{- end }}
	Args     []*argDef
	Flags    []*flagDef
	Subs     []*commandDef
	Parent   *commandDef
	Examples []string
}

type topicDef struct {
	Name string
	Desc string
	Text string
}

type globalFlags struct {
{{- range .GlobalFlags }}
	{{ goFieldName .Name }} {{ goTypeForFlag .Type }}
{{- end }}
{{- if eq (len .GlobalFlags) 0 }}
	_ struct{}
{{- end }}
}

{{- range .Leafs }}
{{- $base := lowerFirst (goNameForPath (cmdPath .)) }}

type {{ $base }}Params struct {
	globalFlags
{{- if .Args }}
{{- range .Args }}
	{{ goFieldName .Name }} {{ goTypeForArg .Type }}
{{- end }}
{{- end }}
{{- if .Flags }}
{{- range .Flags }}
	{{ goFieldName .Name }} {{ goTypeForFlag .Type }}
{{- end }}
{{- end }}
{{- if and (not .Args) (not .Flags) }}
	_ struct{}
{{- end }}
}
{{- end }}

type Handlers interface {
{{- range .Leafs }}
	{{ goNameForPath (cmdPath .) }}(params *{{ lowerFirst (goNameForPath (cmdPath .)) }}Params) Action
{{- end }}
}

var cliGlobalFlags = []*flagDef{
{{- range .GlobalFlags }}
	{Name: {{ printf "%q" .Name }}, Short: {{ printf "%q" .Short }}, Type: {{ printf "%q" .Type }}, Desc: {{ printf "%q" .Desc }}},
{{- end }}
}

var cliTopics = []*topicDef{
{{- range .Topics }}
	{Name: {{ printf "%q" .Name }}, Desc: {{ printf "%q" .Desc }}, Text: {{ printf "%q" .Text }}},
{{- end }}
}

var cliCommands = buildCommands()

func buildCommands() []*commandDef {
{{- range .AllCommands }}
{{- $c := . }}
	{{ cmdVar . }} := &commandDef{Name: {{ printf "%q" .Name }}, Desc: {{ printf "%q" .Desc }}{{- if .Parent }}, Parent: {{ cmdVar .Parent }}{{- end }}{{- range $p := $.ParamDefs }}, {{ goFieldName $p.Name }}: {{ paramLiteral $c $p.Name $p.Kind }}{{- end }}{{- if .Args }}, Args: []*argDef{ {{- range .Args }}{Name: {{ printf "%q" .Name }}, Type: {{ printf "%q" .Type }}, Desc: {{ printf "%q" .Desc }}},{{- end }} }{{- end }}{{- if .Flags }}, Flags: []*flagDef{ {{- range .Flags }}{Name: {{ printf "%q" .Name }}, Short: {{ printf "%q" .Short }}, Type: {{ printf "%q" .Type }}, Desc: {{ printf "%q" .Desc }}},{{- end }} }{{- end }}{{- if .Examples }}, Examples: []string{ {{- range .Examples }}{{ printf "%q" . }},{{- end }} }{{- end }} }
{{- end }}
{{- range .AllCommands }}
{{- if .Subs }}
	{{ cmdVar . }}.Subs = []*commandDef{ {{- range .Subs }}{{ cmdVar . }},{{- end }} }
{{- end }}
{{- end }}

	return []*commandDef{ {{- range .Commands }}{{ cmdVar . }},{{- end }} }
}

type invocation struct {
	Command *commandDef
	Args    map[string]string
	Flags   map[string]any
}

func Parse(h Handlers, args []string) (Action, error) {
	if h == nil {
		return nil, fmt.Errorf("handlers is nil")
	}
	var gf globalFlags
	var remaining []string
	help := false
	for i := 0; i < len(args); i++ {
		arg := args[i]
		if arg == "--help" || arg == "-h" {
			help = true
			continue
		}
		found := false
		for _, f := range cliGlobalFlags {
			if arg == "--"+f.Name || (f.Short != "" && arg == "-"+f.Short) {
				found = true
				if f.Type == "bool" {
					applyGlobalFlag(&gf, f.Name, true)
				} else if f.Type == "string" && i+1 < len(args) {
					applyGlobalFlag(&gf, f.Name, args[i+1])
					i++
				}
			}
		}
		if !found {
			remaining = append(remaining, arg)
		}
	}
	if help || len(remaining) == 0 {
		return helpAction(remaining), nil
	}
	if remaining[0] == "help" {
		return helpAction(remaining[1:]), nil
	}
	inv := &invocation{Args: make(map[string]string), Flags: make(map[string]any)}
	finalInv, err := resolve(inv, cliCommands, remaining)
	if err != nil {
		return nil, err
	}
	if finalInv == nil || finalInv.Command == nil {
		return nil, fmt.Errorf("no command resolved")
	}
	path := getCmdPath(finalInv.Command)
	switch path {
{{- range .Leafs }}
	case {{ printf "%q" (cmdPath .) }}:
		params := &{{ lowerFirst (goNameForPath (cmdPath .)) }}Params{}
{{- range .Args }}
		params.{{ goFieldName .Name }} = finalInv.Args[{{ printf "%q" .Name }}]
{{- end }}
		params.globalFlags = gf
{{- range .Flags }}
{{- if eq .Type "bool" }}
		params.{{ goFieldName .Name }} = boolFlag(finalInv.Flags, {{ printf "%q" .Name }})
{{- else if eq .Type "string" }}
		params.{{ goFieldName .Name }} = stringFlag(finalInv.Flags, {{ printf "%q" .Name }})
{{- end }}
{{- end }}
		action := h.{{ goNameForPath (cmdPath .) }}(params)
		if action == nil {
			return nil, fmt.Errorf("no handler for command: %s", path)
		}
		return action, nil
{{- end }}
	case "help":
		return helpAction(nil), nil
	default:
		return nil, fmt.Errorf("no handler for command: %s", path)
	}
}

func helpAction(args []string) Action {
	return func() (*ExecutionResult, error) {
		printHelp(args...)
		return &ExecutionResult{ExitCode: 0}, nil
	}
}

func applyGlobalFlag(g *globalFlags, name string, val any) {
	switch name {
{{- range .GlobalFlags }}
	case {{ printf "%q" .Name }}:
{{- if eq .Type "bool" }}
		if b, ok := val.(bool); ok {
			g.{{ goFieldName .Name }} = b
		}
{{- else if eq .Type "string" }}
		if s, ok := val.(string); ok {
			g.{{ goFieldName .Name }} = s
		}
{{- end }}
{{- end }}
	}
}

func boolFlag(flags map[string]any, name string) bool {
	if v, ok := flags[name]; ok {
		if b, ok := v.(bool); ok {
			return b
		}
	}
	return false
}

func stringFlag(flags map[string]any, name string) string {
	if v, ok := flags[name]; ok {
		if s, ok := v.(string); ok {
			return s
		}
	}
	return ""
}

func resolve(inv *invocation, cmds []*commandDef, args []string) (*invocation, error) {
	word := args[0]
	var matches []*commandDef
	for _, c := range cmds {
		if c.Name == word {
			matches = []*commandDef{c}
			break
		}
		if strings.HasPrefix(c.Name, word) {
			matches = append(matches, c)
		}
	}
	if len(matches) > 1 {
		var names []string
		for _, m := range matches {
			names = append(names, m.Name)
		}
		return nil, fmt.Errorf("ambiguous command: %s (candidates: %s)", word, strings.Join(names, ", "))
	}
	if len(matches) == 1 {
		cmd := matches[0]
		currArgs := args[1:]
		if len(currArgs) > 0 && (currArgs[0] == "--help" || currArgs[0] == "-h") {
			return nil, fmt.Errorf("help requested for %s", cmd.Name)
		}
		if len(currArgs) > 0 && len(cmd.Subs) > 0 {
			subInv, err := resolve(inv, cmd.Subs, currArgs)
			if err == nil {
				return subInv, nil
			}
			if !strings.HasPrefix(err.Error(), "unknown command") {
				return nil, err
			}
		}
		if len(cmd.Subs) > 0 {
			return nil, fmt.Errorf("unknown command: %s %s", cmd.Name, currArgs[0])
		}
		inv.Command = cmd
		if err := parseParams(inv, cmd, currArgs); err != nil {
			return nil, err
		}
		return inv, nil
	}
	if len(cmds) == len(cliCommands) {
		var subMatches []*commandDef
		for _, c := range cmds {
			for _, s := range c.Subs {
				if s.Name == word || strings.HasPrefix(s.Name, word) {
					subMatches = append(subMatches, s)
				}
			}
		}
		if len(subMatches) > 1 {
			var names []string
			for _, m := range subMatches {
				names = append(names, getCmdPath(m))
			}
			return nil, fmt.Errorf("ambiguous command: %s (candidates: %s)", word, strings.Join(names, ", "))
		}
		if len(subMatches) == 1 {
			s := subMatches[0]
			inv.Command = s
			if err := parseParams(inv, s, args[1:]); err != nil {
				return nil, err
			}
			return inv, nil
		}
	}
	return nil, fmt.Errorf("unknown command: %s", word)
}

func parseParams(inv *invocation, cmd *commandDef, args []string) error {
	argIdx := 0
	for i := 0; i < len(args); i++ {
		arg := args[i]
		if strings.HasPrefix(arg, "-") {
			found := false
			for _, f := range cmd.Flags {
				if arg == "--"+f.Name || (f.Short != "" && arg == "-"+f.Short) {
					if f.Type == "bool" {
						inv.Flags[f.Name] = true
						found = true
					} else if f.Type == "string" && i+1 < len(args) {
						inv.Flags[f.Name] = args[i+1]
						i++
						found = true
					}
					break
				}
			}
			if !found {
				if argIdx < len(cmd.Args) {
					inv.Args[cmd.Args[argIdx].Name] = arg
					argIdx++
				}
			}
		} else {
			if argIdx < len(cmd.Args) {
				inv.Args[cmd.Args[argIdx].Name] = arg
				argIdx++
			}
		}
	}
	if argIdx < len(cmd.Args) {
		if len(cmd.Args) == 1 && cmd.Parent != nil && cmd.Parent.Name == "pkg" && cmd.Name == "list" {
			if v, ok := inv.Flags["index"]; ok {
				if b, ok := v.(bool); ok && b {
					return nil
				}
			}
		}
		return fmt.Errorf("argument %s is missing", cmd.Args[argIdx].Name)
	}
	return nil
}

type helpData struct {
	Topic   *topicDef
	Command *commandDef
	Root    *rootHelpData
	CommandPath string
}

type rootHelpData struct {
	GlobalFlags []*flagDef
	Topics      []*topicDef
	Categories  []categoryDef
}

type categoryDef struct {
	Name string
	Cmds []cmdItem
}

type cmdItem struct {
	Cmd    *commandDef
}

func printHelp(args ...string) {
	if len(args) > 0 {
		subject := args[0]
		for _, topic := range cliTopics {
			if topic.Name == subject || strings.HasPrefix(topic.Name, subject) {
				renderHelp(&helpData{Topic: topic})
				return
			}
		}
		curr := cliCommands
		var found *commandDef
		for _, arg := range args {
			var match *commandDef
			for _, c := range curr {
				if c.Name == arg || strings.HasPrefix(c.Name, arg) {
					match = c
					break
				}
			}
			if match == nil {
				break
			}
			found = match
			curr = match.Subs
		}
		if found != nil {
			renderHelp(&helpData{Command: found, CommandPath: getCmdPath(found)})
			return
		}
	}

	// Root help
	categories := []struct {
		name string
		cmds []string
	}{
		{"PACKAGE", []string{"pkg"}},
		{"CAVE", []string{"cave"}},
		{"DISK", []string{"disk"}},
		{"REPO", []string{"repo"}},
	}

	var cats []categoryDef
	shown := make(map[string]bool)

	for _, cat := range categories {
		var items []cmdItem
		for _, name := range cat.cmds {
			for _, c := range cliCommands {
				if c.Name == name {
					items = append(items, cmdItem{Cmd: c})
					shown[c.Name] = true
				}
			}
		}
		if len(items) > 0 {
			cats = append(cats, categoryDef{Name: cat.name, Cmds: items})
		}
	}

	var misc []cmdItem
	for _, c := range cliCommands {
		if !shown[c.Name] && c.Name != "help" {
			misc = append(misc, cmdItem{Cmd: c})
		}
	}
	if len(misc) > 0 {
		cats = append(cats, categoryDef{Name: "MISC", Cmds: misc})
	}

	renderHelp(&helpData{Root: &rootHelpData{
		GlobalFlags: cliGlobalFlags,
		Topics:      cliTopics,
		Categories:  cats,
	}})
}

const helpTemplate = {{ printf "%q" .HelpTemplate }}

func renderHelp(data *helpData) {
	tmpl := template.New("help")
	template.Must(tmpl.Parse(helpTemplate))
	if err := tmpl.Execute(os.Stdout, data); err != nil {
		fmt.Fprintf(os.Stderr, "help render error: %v\n", err)
	}
}

func getCmdPath(c *commandDef) string {
	if c.Parent == nil {
		return c.Name
	}
	return getCmdPath(c.Parent) + "/" + c.Name
}
`
