# pi (package-installer) - Rust
deps: clap, log, env_logger, starlark(0.13.0), anyhow, allocative, serde, serde_json, parking_lot, regex, ureq, sha2, hex, dirs-next, serde_json_path, comfy-table

src/
 models/
  package_entry: PackageEntry { regexp, function_name, filename }
  version_entry: VersionEntry { pkgname, version, release_date, release_type, url, filename, checksum, checksum_url }
  context: Context { os, arch, filename, download_dir, packages: RwLock, versions: RwLock }
 starlark/
  api: register_api (get_os, get_arch, add_package, download, json_parse, json_dump, add_version)
  runtime: evaluate_file -> Vec<PackageEntry>, execute_function -> Vec<VersionEntry>
 services/
  downloader: ureq-based GET requests
  cache: SHA256-hashed filenames, TTL-based validation
 cli/parser: Cli { verbose }, Repo { Add, Sync, List }, Devel { Test { filename, pkg } }
 logging/init: init_logging(verbose)
 commands/repo:
  - add: register repo path, generate UUID, store in repositories.json, trigger sync
  - sync: walk repo for .star files, evaluate, cache packages-<uuid>.json, trigger list
  - list: display table of repo, package regexp, and discovery function
 commands/devel/test:
  1. evaluate_file -> collect PackageEntry list
  2. if pkg: match regex -> execute_function -> collect VersionEntry list
  3. sort versions (date, version) -> print table (comfy-table)

logic:
- json_parse: trick using eval_statements("json") to get built-in module then calling .decode()
- json_dump: converts Starlark -> Serde, applies JSONPath (serde_json_path), prints pretty JSON
- add_version: stores metadata including checksum_url; type logic (stable/lts/obsolete) handled in .star
- sorting: VersionEntry sorted by release_date then version string before display